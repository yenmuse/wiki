
                <html lang="en" class="simpread-font simpread-theme-root" style='font-size: 60%!important;'>
                    <head>
                        <meta charset="utf-8">
                        <meta http-equiv="content-type" content="text/html; charset=UTF-8;charset=utf-8">
                        <meta http-equiv="X-UA-Compatible" content="IE=Edge">
                        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=1">
                        <meta name="author" content="Kenshin"/>
                        <meta name="description" content="简悦 SimpRead - 如杂志般沉浸式阅读体验的扩展" />
                        <meta name="keywords" content="Chrome extension, Chrome 扩展, 阅读模式, 沉浸式阅读, 简悦, 简阅, read mode, reading mode, reader view, firefox, firefox addon, userscript, safari, opera, tampermonkey"/>
                        <meta name="thumbnail" content="https://simpread-1254315611.cos.ap-shanghai.myqcloud.com/static/introduce-2.png"/>
                        <meta property="og:title" content="简悦 SimpRead - 如杂志般沉浸式阅读体验的扩展"/>
                        <meta property="og:type" content="website">
                        <meta property="og:local" content="zh_CN"/>
                        <meta property="og:url" content="http://ksria.com/simpread"/>
                        <meta property="og:image" content="https://simpread-1254315611.cos.ap-shanghai.myqcloud.com/static/introduce-2.png"/>
                        <meta property="og:image:type" content="image/png"/>
                        <meta property="og:image:width" content="960"/>
                        <meta property="og:image:height" content="355"/>
                        <meta property="og:site_name" content="http://ksria.com/simpread"/>
                        <meta property="og:description" content="简悦 SimpRead - 如杂志般沉浸式阅读体验的扩展"/>
                        <style type="text/css">.simpread-font{font:300 16px/1.8 -apple-system,PingFang SC,Microsoft Yahei,Lantinghei SC,Hiragino Sans GB,Microsoft Sans Serif,WenQuanYi Micro Hei,sans-serif;color:#333;text-rendering:optimizelegibility;-webkit-text-size-adjust:100%;-webkit-font-smoothing:antialiased}.simpread-hidden{display:none}.simpread-read-root{display:-webkit-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;position:relative;margin:0;top:-1000px;left:0;width:100%;z-index:2147483646;overflow-x:hidden;opacity:0;-webkit-transition:all 1s cubic-bezier(.23,1,.32,1) .1s;transition:all 1s cubic-bezier(.23,1,.32,1) .1s}.simpread-read-root-show{top:0}.simpread-read-root-hide{top:1000px}sr-read{display:-webkit-flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-flow:column nowrap;flex-flow:column;margin:20px 20%;min-width:400px;min-height:400px;text-align:center}read-process{position:fixed;top:0;left:0;height:3px;width:100%;background-color:#64b5f6;-webkit-transition:width 2s;transition:width 2s;z-index:20000}sr-rd-content-error{display:block;position:relative;margin:0;margin-bottom:30px;padding:25px;background-color:rgba(0,0,0,.05)}sr-rd-footer{-webkit-box-orient:vertical;-ms-flex-direction:column;flex-direction:column;font-size:14px}sr-rd-footer,sr-rd-footer-group{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-direction:normal}sr-rd-footer-group{-webkit-box-orient:horizontal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}sr-rd-footer-line{width:100%;border-top:1px solid #e0e0e0}sr-rd-footer-text{min-width:150px}sr-rd-footer-copywrite{margin:10px 0 0;color:inherit}sr-rd-footer-copywrite abbr{-webkit-font-feature-settings:normal;font-feature-settings:normal;font-variant:normal;text-decoration:none}sr-rd-footer-copywrite .second{margin:10px 0}sr-rd-footer-copywrite .third a:hover{border:none!important}sr-rd-footer-copywrite .third a:first-child{margin-right:50px}sr-rd-footer-copywrite .sr-icon{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:33px;height:33px;opacity:.8;-webkit-transition:opacity .5s ease;transition:opacity .5s ease;cursor:pointer}sr-rd-footer-copywrite .sr-icon:hover{opacity:1}sr-rd-footer-copywrite a,sr-rd-footer-copywrite a:link,sr-rd-footer-copywrite a:visited{margin:0;padding:0;color:inherit;background-color:transparent;font-size:inherit!important;line-height:normal;text-decoration:none;vertical-align:baseline;vertical-align:initial;border:none!important;box-sizing:border-box}sr-rd-footer-copywrite a:focus,sr-rd-footer-copywrite a:hover,sr-rd-footer a:active{color:inherit;text-decoration:none;border-bottom:1px dotted!important}.simpread-blocks{text-decoration:none!important}.simpread-blocks *{margin:0}.simpread-blocks a{padding:0;text-decoration:none!important}.simpread-blocks img{margin:0;padding:0;border:0;background:transparent;box-shadow:none}.simpread-focus-root{display:block;position:fixed;top:0;left:0;right:0;bottom:0;background-color:hsla(0,0%,92%,.9);z-index:2147483645;opacity:0;-webkit-transition:opacity 1s cubic-bezier(.23,1,.32,1) 0ms;transition:opacity 1s cubic-bezier(.23,1,.32,1) 0ms}.simpread-focus-highlight{position:relative;box-shadow:0 0 0 20px #fff;background-color:#fff;overflow:visible;z-index:2147483646}.sr-controlbar-bg sr-rd-crlbar,.sr-controlbar-bg sr-rd-crlbar fab{z-index:2147483647}sr-rd-crlbar.controlbar{position:fixed;right:0;bottom:0;width:100px;height:100%;opacity:0;-webkit-transition:opacity .5s ease;transition:opacity .5s ease}sr-rd-crlbar.controlbar:hover{opacity:1}sr-rd-crlbar fap *{box-sizing:border-box}@media (max-height:620px){fab{zoom:.8}}@media (max-height:783px){dialog-gp dialog-content{max-height:580px}dialog-gp dialog-footer{border-top:1px solid #e0e0e0}}.simpread-highlight-selector{outline:3px dashed #1976d2!important;cursor:pointer!important}.simpread-highlight-controlbar,.simpread-highlight-selector{background-color:#fafafa!important;opacity:.8!important;-webkit-transition:opacity .5s ease!important;transition:opacity .5s ease!important}.simpread-highlight-controlbar{position:relative!important;border:3px dashed #1976d2!important}simpread-highlight,sr-snapshot-ctlbar{position:fixed;top:0;left:0;right:0;padding:15px;height:50px;background-color:rgba(50,50,50,.9);box-shadow:0 2px 5px rgba(0,0,0,.26);box-sizing:border-box;z-index:2147483640}simpread-highlight,sr-highlight-ctl,sr-snapshot-ctlbar{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}sr-highlight-ctl{margin:0 5px;width:50px;height:20px;color:#fff;background-color:#1976d2;border-radius:4px;box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);cursor:pointer}toc-bg{position:fixed;left:0;top:0;width:50px;height:200px;font-size:medium}toc-bg:hover{z-index:3}.toc-bg-hidden{opacity:0;-webkit-transition:opacity .5s ease;transition:opacity .5s ease}.toc-bg-hidden:hover{opacity:1;z-index:3}.toc-bg-hidden:hover toc{width:180px}toc *{all:unset}toc{position:fixed;left:0;top:100px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;padding:10px;width:0;max-width:200px;max-height:500px;overflow-x:hidden;overflow-y:hidden;cursor:pointer;border:1px solid hsla(0,0%,62%,.22);-webkit-transition:width .5s;transition:width .5s}toc:hover{overflow-y:auto}toc.mini:hover{width:200px!important}toc::-webkit-scrollbar{width:3px}toc::-webkit-scrollbar-thumb{border-radius:10px;background-color:hsla(36,2%,54%,.5)}toc outline{position:relative;display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden;text-overflow:ellipsis;padding:2px 0;min-height:21px;line-height:21px;text-align:left}toc outline a,toc outline a:active,toc outline a:focus,toc outline a:visited{display:block;width:100%;color:inherit;font-size:11px;text-decoration:none!important;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}toc outline a:hover{font-weight:700!important}toc outline a.toc-outline-theme-dark,toc outline a.toc-outline-theme-night{color:#fff!important}.toc-level-h1{padding-left:5px}.toc-level-h2{padding-left:15px}.toc-level-h3{padding-left:25px}.toc-level-h4{padding-left:35px}.toc-outline-active{border-left:2px solid #f44336}toc outline active{position:absolute;left:0;top:0;bottom:0;padding:0 0 0 3px;border-left:2px solid #e8e8e8}sr-kbd{background:-webkit-gradient(linear,0 0,0 100%,from(#fff785),to(#ffc542));border:1px solid #e3be23;-o-border-image:none;border-image:none;-o-border-image:initial;border-image:initial;position:absolute;left:0;padding:1px 3px 0;font-size:11px!important;font-weight:700;box-shadow:0 3px 7px 0 rgba(0,0,0,.3);overflow:hidden;border-radius:3px}.sr-kbd-a{position:relative}kbd-mapping{position:fixed;left:5px;bottom:5px;-ms-flex-flow:row;flex-flow:row;width:250px;height:500px;background-color:#fff;border:1px solid hsla(0,0%,62%,.22);box-shadow:0 2px 5px rgba(0,0,0,.26);border-radius:3px}kbd-mapping,kbd-maps{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}kbd-maps{margin:40px 0 20px;width:100%;overflow-x:auto}kbd-maps::-webkit-scrollbar-thumb{background-clip:padding-box;border-radius:10px;border:2px solid transparent;background-color:rgba(85,85,85,.55)}kbd-maps::-webkit-scrollbar{width:10px;-webkit-transition:width .7s cubic-bezier(.4,0,.2,1);transition:width .7s cubic-bezier(.4,0,.2,1)}kbd-mapping kbd-map-title{position:absolute;margin:5px 0;width:100%;font-size:14px;font-weight:700}kbd-maps-group{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}kbd-maps-title{margin:5px 0;padding-left:53px;font-size:12px;font-weight:700}kbd-map kbd{display:inline-block;padding:3px 5px;font-size:11px;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5}kbd-map kbd-name{display:inline-block;text-align:right;width:50px}kbd-map kbd-desc{padding-left:3px}sharecard-bg{position:fixed;top:0;left:0;width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:rgba(0,0,0,.4);z-index:2147483647}sharecard{max-width:450px;background-color:#64b5f6}sharecard,sharecard-head{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}sharecard-head{margin:25px;color:#fff;border-radius:10px;box-shadow:0 2px 6px 0 rgba(0,0,0,.2),0 25px 50px 0 rgba(0,0,0,.15)}sharecard-card{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}sharecard-card,sharecard-top{display:-webkit-box;display:-ms-flexbox;display:flex}sharecard-top{-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding-right:5px;height:65px;background-color:#fff;color:#878787;font-size:25px;font-weight:500;border-top-left-radius:10px;border-top-right-radius:10px}sharecard-top span.logos{display:block;width:48px;height:48px;margin:5px;background-repeat:no-repeat;background-position:50%;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAABU1BMVEUAAAAnNJMnNZI3Q5onNJInNJMnNJInNJMnNJI8SJ0tOZY/S55EUKAoNJI6RpwoNJNIU6InNJInNJImNJI7SJwmNJJ2fLUiMJFKVaNCTJ9faK1HUaJOWKVSXaUnNJNYY6pye7cmM5JXYKhwebMjMI8mL4719fW9vb0oNZP/UlLz8/QqN5TAwMAnNJPv7+/Pz8/q6+/p6enNzc3Kysry8vMsOJXc3env7/LU1uXo29vR0dHOzs7ExMTwjo73bW37XV3Aj1TCYELl5u3n5+fW2Obn6O7f4OrZ2+g0QJkxPpgvO5bh4uvS1OTP0ePCwsJQW6ZLVqTs7fHd3d3V1dXqv79VX6lET6A1TIxXUIBSgHxWQnpelHf+WVnopkXqbC7j5Ozi4uLDw8NGUaFATJ9SgH3r6+vGyd7BxNva2trX19ejqM2gpczHx8dze7Zha67Z2dlTgH1aXQeSAAAAJnRSTlMA6ff+497Y8NL+/fv49P379sqab/BeOiX06tzVy8m/tKqpalA7G6oKj0EAAAJlSURBVEjHndNXWxpBFIDhcS2ICRLAkt4Dx4WhLk0E6R0MYoIISrWX5P9f5cwSIRC2+T1czMV5n2FnZwn2eWONUqCAv3H2Uf5Ra1hx4+0WEXtDQW0fCPYJ1EffEfIV4CSROAE4jsePoTFsNmTJF/IeIHF2lgCIn57GodlqDWXBK7IwBYatVlMWFAildPKX7I3m74Z9fsCiQChoimoFQAz04Ad2gH1n9fv9n9hgMNDr9euLWD6fLxQKxaLfb7dTSlahbFVdEPwIQtrAihZQgyKCtCagbQe3xh0QFMgy5MR11+ewYY5/qlZ7vT2xu93ULKjbFLpiUxnIIwjgKmVTLDUFXMrAi2NJWCRLIthTBo4xyOLKpwyqU6CuDCI41hFBCVdOhyLw4FgJ1skCAiyl9BSHbCorgo6VJXTru5hrVCQS8Yr5xLzX59YJSFpVFwD9U0BGC3hGdFpATgRupTGe9R9I1b1ePBvXKDyvq/O/44LT4/E4BUbSCAwj8Evq6HlnOBprx6JhJz8Gktc7xeaP9ndY+0coQvCccFBD4JW60UIY50ciLOAODAQRVOeCHm4Q3Xks6uRDY+CQ+AR4T2wMYh6+jMCIQOp78CFoj0H7EQgIuhI3dGaHCrwgADwCPjJvA372GRigCJg49FUdk3D87pq3zp4SA5zc1Zh9DxfwkpjgUg5Mv+lbeE3McC8Lpu7SA3wk2xzcqL2tN5DfIsQC8HB7UamUy6FQOpTO5QKBQDZbKnWSyUzGjdWCwaDA8+7Le4BNgm3qQGWchYh9s5hNq6wVbBlbwhZYOp3OYOA4zmgEypnM2zj8ByIdedKrH8vDAAAAAElFTkSuQmCC");zoom:.8}sharecard-content{padding:15px;max-height:500px;font-size:20px;text-align:justify;background-color:#2196f3;overflow-x:hidden;overflow-y:auto}sharecard-via{padding:10px;font-size:10px;background-color:#2196f3}sharecard-footer{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding-right:5px;height:100px;background-color:#fff;color:#878787;font-size:15px;font-weight:500;border-bottom-left-radius:10px;border-bottom-right-radius:10px}sharecard-footer,sharecard-footer div{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}sharecard-footer span.qrcode{display:block;width:100px;height:100px;margin:5px;background-repeat:no-repeat;background-position:50%;background-image:url("data:image/png;base64,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")}sharecard-control{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:0 19px;height:80px;background-color:#fff}simpread-snapshot{width:100%;height:100%;cursor:move;z-index:2147483645}simpread-snapshot,sr-mask{position:fixed;left:0;top:0}sr-mask{background-color:rgba(0,0,0,.1)}.simpread-feedback,.simpread-urlscheme{position:fixed;right:20px;bottom:20px;z-index:2147483646}simpread-feedback,simpread-urlscheme{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;padding:20px 20px 0;width:500px;color:rgba(51,51,51,.87);background-color:#fff;border-radius:3px;box-shadow:0 0 2px rgba(0,0,0,.12),0 2px 2px rgba(0,0,0,.26);overflow:hidden;-webkit-transform-origin:bottom;transform-origin:bottom;-webkit-transition:all .6s ease;transition:all .6s ease}simpread-feedback *,simpread-urlscheme *{font-size:12px!important;box-sizing:border-box}simpread-feedback.active,simpread-urlscheme.active{-webkit-animation-name:srFadeInUp;animation-name:srFadeInUp;-webkit-animation-duration:.45s;animation-duration:.45s;-webkit-animation-fill-mode:both;animation-fill-mode:both}simpread-feedback.hide,simpread-urlscheme.hide{-webkit-animation-name:srFadeInDown;animation-name:srFadeInDown;-webkit-animation-duration:.45s;animation-duration:.45s;-webkit-animation-fill-mode:both;animation-fill-mode:both}simpread-feedback sr-fb-label,simpread-urlscheme sr-urls-label{width:100%}simpread-feedback sr-fb-head,simpread-urlscheme sr-urls-head{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;margin-bottom:5px;width:100%}simpread-feedback sr-fb-content,simpread-urlscheme sr-urls-content{margin-bottom:5px;width:100%}simpread-feedback sr-urls-footer,simpread-urlscheme sr-urls-footer{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;width:100%}simpread-feedback sr-fb-a,simpread-urlscheme sr-urls-a{color:#2163f7;cursor:pointer}simpread-feedback text-field-state,simpread-urlscheme text-field-state{border-top:none rgba(34,101,247,.8)!important;border-left:none rgba(34,101,247,.8)!important;border-right:none rgba(34,101,247,.8)!important;border-bottom:2px solid rgba(34,101,247,.8)!important}simpread-feedback switch,simpread-urlscheme switch{margin-top:0!important}@-webkit-keyframes srFadeInUp{0%{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes srFadeInUp{0%{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes srFadeInDown{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}}@keyframes srFadeInDown{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}}simpread-feedback sr-fb-head{font-weight:700}simpread-feedback sr-fb-content{-webkit-box-orient:vertical;-ms-flex-direction:column;flex-direction:column}simpread-feedback sr-fb-content,simpread-feedback sr-fb-footer{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-direction:normal}simpread-feedback sr-fb-footer{-webkit-box-orient:horizontal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;width:100%}simpread-feedback sr-close{position:absolute;right:20px;cursor:pointer;-webkit-transition:all 1s cubic-bezier(.23,1,.32,1) .1s;transition:all 1s cubic-bezier(.23,1,.32,1) .1s;z-index:200}simpread-feedback sr-close:hover{-webkit-transform:rotate(-15deg) scale(1.3);transform:rotate(-15deg) scale(1.3)}simpread-feedback sr-stars{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-top:10px}simpread-feedback sr-stars i{margin-right:10px;cursor:pointer}simpread-feedback sr-stars i svg{-webkit-transition:all 1s cubic-bezier(.23,1,.32,1) .1s;transition:all 1s cubic-bezier(.23,1,.32,1) .1s}simpread-feedback sr-stars i svg:hover{-webkit-transform:rotate(-15deg) scale(1.3);transform:rotate(-15deg) scale(1.3)}simpread-feedback sr-stars i.active svg{-webkit-transform:rotate(0) scale(1);transform:rotate(0) scale(1)}simpread-feedback sr-emojis{display:block;height:100px;overflow:hidden}simpread-feedback sr-emoji{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-transition:.3s;transition:.3s}simpread-feedback sr-emoji>svg{margin:15px 0;width:70px;height:70px;-ms-flex-negative:0;flex-shrink:0}simpread-feedback sr-stars-footer{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin:10px 0 20px}</style>
                        <style type="text/css">.simpread-theme-root{font-size:62.5%!important}sr-rd-content,sr-rd-desc,sr-rd-title{width:100%}sr-rd-title{display:-webkit-box;margin:1em 0 .5em;overflow:hidden;text-overflow:ellipsis;text-rendering:optimizelegibility;-webkit-line-clamp:3;-webkit-box-orient:vertical}sr-rd-content{text-align:left;word-break:break-word}sr-rd-desc{text-align:justify;line-height:2.4;margin:0 0 1.2em;box-sizing:border-box}sr-rd-content{font-size:25.6px;font-size:1.6rem;line-height:1.6}sr-rd-content h1,sr-rd-content h1 *,sr-rd-content h2,sr-rd-content h2 *,sr-rd-content h3,sr-rd-content h3 *,sr-rd-content h4,sr-rd-content h4 *,sr-rd-content h5,sr-rd-content h5 *,sr-rd-content h6,sr-rd-content h6 *{word-break:break-all}sr-rd-content div,sr-rd-content p{display:block;float:inherit;line-height:1.6;font-size:25.6px;font-size:1.6rem}sr-rd-content div,sr-rd-content p,sr-rd-content pre,sr-rd-content sr-blockquote{margin:0 0 1.2em;word-break:break-word}sr-rd-content a{padding:0 5px;vertical-align:baseline;vertical-align:initial}sr-rd-content a,sr-rd-content a:link{color:inherit;font-size:inherit;font-weight:inherit;border:none}sr-rd-content a:hover{background:transparent}sr-rd-content img{margin:10px;padding:5px;max-width:100%;background:#fff;border:1px solid #bbb;box-shadow:1px 1px 3px #d4d4d4}sr-rd-content figcaption{text-align:center;font-size:14px}sr-rd-content sr-blockquote{display:block;position:relative;padding:15px 25px;text-align:left;line-height:inherit}sr-rd-content sr-blockquote:before{position:absolute}sr-rd-content sr-blockquote *{margin:0;font-size:inherit}sr-rd-content table{width:100%;margin:0 0 1.2em;word-break:keep-all;word-break:normal;overflow:auto;border:none}sr-rd-content table td,sr-rd-content table th{border:none}sr-rd-content ul{margin:0 0 1.2em;margin-left:1.3em;padding:0;list-style:disc}sr-rd-content ol{list-style:decimal;margin:0;padding:0}sr-rd-content ol li,sr-rd-content ul li{font-size:inherit;list-style:disc;margin:0 0 1.2em}sr-rd-content ol li{list-style:decimal;margin-left:1.3em}sr-rd-content ol li *,sr-rd-content ul li *{margin:0;text-align:left;text-align:initial}sr-rd-content li ol,sr-rd-content li ul{margin-bottom:.8em;margin-left:2em}sr-rd-content li ul{list-style:circle}sr-rd-content pre{font-family:Consolas,Monaco,Andale Mono,Source Code Pro,Liberation Mono,Courier,monospace;display:block;padding:15px;line-height:1.5;word-break:break-all;word-wrap:break-word;white-space:pre;overflow:auto}sr-rd-content pre,sr-rd-content pre *,sr-rd-content pre div{font-size:17.6px;font-size:1.1rem}sr-rd-content li pre code,sr-rd-content p pre code,sr-rd-content pre{background-color:transparent;border:none}sr-rd-content pre code{margin:0;padding:0}sr-rd-content pre code,sr-rd-content pre code *{font-size:17.6px;font-size:1.1rem}sr-rd-content pre p{margin:0;padding:0;color:inherit;font-size:inherit;line-height:inherit}sr-rd-content li code,sr-rd-content p code{margin:0 4px;padding:2px 4px;font-size:17.6px;font-size:1.1rem}sr-rd-content mark{margin:0 5px;padding:2px;background:#fffdd1;border-bottom:1px solid #ffedce}.sr-rd-content-img{width:90%;height:auto}.sr-rd-content-img-load{width:48px;height:48px;margin:0;padding:0;border-style:none;border-width:0;background-repeat:no-repeat;background-image:url(data:image/gif;base64,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)}.sr-rd-content-center{text-align:center;display:-webkit-box;-webkit-box-align:center;-webkit-box-pack:center;-webkit-box-orient:vertical}.sr-rd-content-center-small{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex}.sr-rd-content-center-small img{margin:0;padding:0;border:0;box-shadow:none}img.simpread-img-broken{cursor:pointer}.sr-rd-content-nobeautify{margin:0;padding:0;border:0;box-shadow:0 0 0}sr-rd-mult{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;margin:0 0 16px;padding:16px 0 24px;width:100%;background-color:#fff;border-radius:4px;box-shadow:0 1px 2px 0 rgba(60,64,67,.3),0 2px 6px 2px rgba(60,64,67,.15)}sr-rd-mult:hover{-webkit-transition:all .45s 0ms;transition:all .45s 0ms;box-shadow:1px 1px 8px rgba(0,0,0,.16)}sr-rd-mult sr-rd-mult-content{padding:0 16px;overflow:auto}sr-rd-mult sr-rd-mult-avatar,sr-rd-mult sr-rd-mult-content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}sr-rd-mult sr-rd-mult-avatar{-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin:0 15px}sr-rd-mult sr-rd-mult-avatar span{display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;max-width:75px;overflow:hidden;text-overflow:ellipsis;text-align:left;font-size:16px;font-size:1rem}sr-rd-mult sr-rd-mult-avatar img{margin-bottom:0;max-width:50px;max-height:50px;width:50px;height:50px;border-radius:50%}sr-rd-mult sr-rd-mult-content img{max-width:80%}sr-rd-mult sr-rd-mult-avatar .sr-rd-content-center{margin:0}sr-page{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;width:100%}</style>
                        <style type="text/css">sr-rd-theme-engwrite{display:none}sr-rd-content h1,sr-rd-content h2,sr-rd-content h3,sr-rd-content h4,sr-rd-content h5,sr-rd-content h6{margin:20px 0 10px;padding:0;font-weight:500;-webkit-font-smoothing:antialiased}sr-rd-content h1{font-weight:300;text-align:center;font-size:44.8px;font-size:2.8rem;color:#933d3f}sr-rd-content h2{font-size:38.4px;font-size:2.4rem;border-bottom:1px solid #ccc;color:#000}sr-rd-content h3{font-size:28.8px;font-size:1.8rem}sr-rd-content h4,sr-rd-content h5,sr-rd-content h6{font-size:25.6px;font-size:1.6rem}sr-rd-content h6{color:#777}sr-rd-content ol,sr-rd-content ul{padding-left:30px}sr-rd-content ol li>:first-child,sr-rd-content ol li ol:first-of-type,sr-rd-content ol li ul:first-of-type,sr-rd-content ul li>:first-child,sr-rd-content ul li ol:first-of-type,sr-rd-content ul li ul:first-of-type{margin-top:0}sr-rd-content ol ol,sr-rd-content ol ul,sr-rd-content ul ol,sr-rd-content ul ul{margin-bottom:0}sr-rd-content table th{font-weight:700}sr-rd-content table td,sr-rd-content table th{border:1px solid #ccc;padding:6px 13px}sr-rd-content table tr{border-top:1px solid #ccc;background-color:#fff}sr-rd-content table tr:nth-child(2n){background-color:#f8f8f8}sr-rd-content sr-blockquote{text-align:left;border-top:1px dotted #cdc7bc;border-bottom:1px dotted #cdc7bc;background-color:#f8edda;color:#777}sr-blockquote>:first-child{margin-top:0}sr-blockquote>:last-child{margin-bottom:0}.simpread-multi-root,.simpread-theme-root{background-color:#fcf5ed;color:#333}sr-rd-title{font-weight:300;text-align:center;font-size:44.8px;font-size:2.8rem;color:#933d3f}sr-rd-desc{padding:10px;background-color:#f8edda;color:#777;font-size:32px;font-size:2rem;text-align:center;border-top:1px dotted #cdc7bc;border-bottom:1px dotted #cdc7bc}sr-rd-content{padding:20px 0;margin:0 auto}sr-rd-content,sr-rd-content *,sr-rd-content div,sr-rd-content p{color:#333;line-height:1.8}sr-rd-content a,sr-rd-content a:link{color:#ae3737;text-decoration:none}sr-rd-content a:active,sr-rd-content a:focus,sr-rd-content a:hover{text-decoration:underline}sr-rd-content pre{background-color:transparent;border:1px solid #ccc;border-radius:3px}sr-rd-content li code,sr-rd-content p code{border:1px solid #eaeaea;background-color:#f4ece3;border-radius:3px}sr-rd-mult{background-color:#f8edda}</style>
                        <style type="text/css"></style>
                        <style type="text/css">@media (pointer:coarse){sr-read{margin:20px 5%!important;min-width:0!important;max-width:90%!important}sr-rd-title{margin-top:0;font-size:2.7rem}sr-rd-content sr-blockquote,sr-rd-desc{margin:10 0!important;padding:0 0 0 10px!important;width:90%;font-size:1.8rem;font-style:normal;line-height:1.7;text-align:justify}sr-rd-content{font-size:1.75rem;font-weight:300}sr-rd-content figure{margin:0;padding:0;text-align:center}sr-rd-content a,sr-rd-content a:link,sr-rd-content li code,sr-rd-content p code{font-size:inherit}sr-rd-footer{margin-top:20px}sr-blockquote,sr-blockquote *{margin:5px!important;padding:5px!important}sr-rd-content h1,sr-rd-content h2,sr-rd-content h3,sr-rd-content h4,sr-rd-content h5,sr-rd-content h6,sr-rd-title{font-family:PingFang SC,Verdana,Helvetica Neue,Microsoft Yahei,Hiragino Sans GB,Microsoft Sans Serif,WenQuanYi Micro Hei,sans-serif;color:#000;font-weight:100;line-height:1.35}sr-rd-content-h1,sr-rd-content-h2,sr-rd-content-h3,sr-rd-content-h4,sr-rd-content-h5,sr-rd-content-h6,sr-rd-content h1,sr-rd-content h2,sr-rd-content h3,sr-rd-content h4,sr-rd-content h5,sr-rd-content h6{margin-top:1.2em;margin-bottom:.6em;line-height:1.35}sr-rd-content-h1,sr-rd-content h1{font-size:1.8em}sr-rd-content-h2,sr-rd-content h2{font-size:1.6em}sr-rd-content-h3,sr-rd-content h3{font-size:1.4em}sr-rd-content-h4,sr-rd-content-h5,sr-rd-content-h6,sr-rd-content h4,sr-rd-content h5,sr-rd-content h6{font-size:1.2em}sr-rd-content-ul,sr-rd-content ul{margin-left:1.3em!important;list-style:disc}sr-rd-content-ol,sr-rd-content ol{list-style:decimal;margin-left:1.9em!important}sr-rd-content-ol ol,sr-rd-content-ol ul,sr-rd-content-ul ol,sr-rd-content-ul ul,sr-rd-content li ol,sr-rd-content li ul{margin-bottom:.8em;margin-left:2em!important}sr-rd-content img{margin:0;padding:0;border:0;max-width:100%!important;height:auto;box-shadow:0 20px 20px -10px rgba(0,0,0,.1)}sr-rd-mult{min-width:0;background-color:#fff;box-shadow:0 1px 6px rgba(32,33,36,.28);border-radius:8px}sr-rd-mult sr-rd-mult-avatar div{margin:0}sr-rd-mult sr-rd-mult-avatar .sr-rd-content-center-small{margin:7px 0!important}sr-rd-mult sr-rd-mult-avatar span{display:block}sr-rd-mult sr-rd-mult-content{padding-left:0}@media only screen and (max-device-width:1024px){.simpread-theme-root,html.simpread-theme-root{font-size:80%!important}sr-rd-mult sr-rd-mult-avatar img{width:50px;height:50px;min-width:50px;min-height:50px}toc-bg toc{width:10px!important}toc-bg:hover toc{width:auto!important}}@media only screen and (max-device-width:414px){.simpread-theme-root,html.simpread-theme-root{font-size:70%!important}sr-rd-mult sr-rd-mult-avatar img{width:30px;height:30px;min-width:30px;min-height:30px}}@media only screen and (max-device-width:320px){.simpread-theme-root,html.simpread-theme-root{font-size:90%!important}sr-rd-content p{margin-bottom:.5em}}}</style>
                        <style type="text/css">sr-rd-content *, sr-rd-content p, sr-rd-content div {}sr-rd-content pre code, sr-rd-content pre code * {}sr-rd-desc {}sr-rd-content pre {}sr-rd-title {}</style>
                        <style type="text/css"></style>
                        <style type="text/css"></style>
                        <style type="text/css"></style>
                        <style type="text/css"></style>
                        <style type="text/css">sr-rd-content *, sr-rd-content p, sr-rd-content div {
        font-size: 15px;
    }

    .annote-perview, .annote-perview * {
        color: rgb(85, 85, 85);
        font-weight: 400;
        line-height: 1.8;
    }</style>
                        
                        
                        <script>setTimeout(()=>{const e=location.hash.replace("#id=","");let t,a=!1;const n=t=>{for(let n of t){let t;if((t=e.length>6?n.getAttribute("data-id"):n.getAttribute("data-idx"))==e){n.scrollIntoView({behavior:"smooth",block:"start",inline:"nearest"}),a=!0;break}}};e&&(0==(t=document.getElementsByClassName("sr-unread-card")).length&&(t=document.getElementsByTagName("sr-annote")),n(t),a||n(t=document.getElementsByClassName("sr-annote")))},500);</script>
                        
                        <title>简悦 | Python behind the scenes #12: how async/await works in Python</title>
                    </head>
                    <body>
                        <sr-read style='font-family: "YaHei Consolas Hybrid"; margin: 20px 30%;'>
                            <sr-rd-title>Python behind the scenes #12: how async/await works in Python</sr-rd-title>
                    <sr-rd-desc style="margin: 0;padding-top: 0;padding-bottom: 0;font-style: normal;font-size: 18px;">Mark functions as async. Call them with await. All of a sudden, your program becomes asynchronous – i......</sr-rd-desc>
                    <sr-rd-content><p></p><p>Mark functions as <code>async</code>. Call them with <code>await</code>. All of a sudden, your program becomes asynchronous – it can do useful things while it waits for other things, such as I/O operations, to complete.</p><p></p><p>Code written in the <code>async</code>/<code>await</code> style looks like regular synchronous code but works very differently. To understand how it works, one should be familiar with many non-trivial concepts including concurrency, parallelism, event loops, I/O multiplexing, asynchrony, cooperative multitasking and coroutines. Python's implementation of <code>async</code>/<code>await</code> adds even more concepts to this list: generators, generator-based coroutines, native coroutines, <code>yield</code> and <code>yield from</code>. Because of this complexity, many Python programmers that use <code>async</code>/<code>await</code> do not realize how it actually works. I believe that it should not be the case. The <code>async</code>/<code>await</code> pattern can be explained in a simple manner if you start from the ground up. And that's what we're going to do today.</p><p></p><p><strong>Note</strong>: In this post I'm referring to CPython 3.9. Some implementation details will certainly change as CPython evolves. I'll try to keep track of important changes and add update notes.</p><p></p><h2 id="sr-toc-0">It's all about concurrency</h2><p></p><p>Computers execute programs sequentially – one instruction after another. But a typical program performs multiple tasks, and it doesn't always make sense to wait for some task to complete before starting the next one. For example, a chess program that waits for a player to make a move should be able to update the clock in the meantime. Such an ability of a program to deal with multiple things simultaneously is what we call <strong>concurrency</strong>. Concurrency doesn't mean that multiple tasks must run at the same physical time. They can run in an interleaved manner: a task runs for some time, then suspends and lets other tasks run, hoping it will get more time in the future. By this mechanism, an OS can run thousands of processes on a machine that has only a few cores. If multiple tasks do run at the same physical time, as in the case of a multi-core machine or a cluster, then we have <strong>parallelism</strong>, a special case of concurrency <a href="#footnote1">[1]</a>.</p><p></p><p><div class="sr-rd-content-center"><img class="sr-rd-content-img" src="data:image/png;base64,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uu2TkpKUpk2bara1WCzKuXPnNNtFRkbqbvP99993uk1FUZTw8HDNY15ElFmzZqnq5+TkKBaLRVU3MDBQOXbsmFv76scff9Tc3uLFi706NrTk5OQoNptNczs2m02JjY112cfHH3+s2d7f31+5evWq07Za7Xbt2lVo47tZamqq7jHQtWtXJSMjQ7ftwYMHdd//VatWqeqb9d2hFeOPP/7o0X66fv265nbXrl2rWX/8+PG6sW7YsEF3O5mZmcpbb72l2a5hw4aabYYMGaJ7rKakpOhua/HixU6/d6xWq27b8PBwzTaemjJliqqPdu3aedRHenq6YrVaNePp1q2bcunSJaft4+PjldDQUN32egYNGqSq/8orr3i8D5o3b67q56233tKtX5i/Z+6aPXu27u/Lr7/+6rL9vHnzdI+zyMhIzTZXr17V/R5u06aNkpOTo2rz+eef625n0aJFxWp8Gzdu1G0zZcoUp9tbsWKFblut33tnn/UdO3bobufAgQO6n63cx5EjR3Tbe3usLly40O3/S5v1e33q1CnNNgkJCS63d7PNmzdr9pOWluZRPwCAWx9JCQCAU0WVlNDr++bH9evXnbZv2LCh0/bJycluxZGYmKh5Yvnmk9EnTpxQnTA4ffq08v777+u2GzlyZJG9L3onXq1WqzJ//nxl27Ztys6dO936IzArK8vlH+kiomzevNnt+FwlJXJPwqxdu9YhUZCYmKgsXbrU6bGhlRy42YABA3Tb9ujRQ9m3b5/DsZWdna3ExMQo7777rm67li1bKpmZmZrbGzNmjG67efPmaZ5oUpS/Txw6O9GbmJhYqMfMmjVrnJ6sXblypXLmzBlVu/379yvPP/+8btuVK1e63LZWu6JKSiiKonz55ZdO38vly5crcXFxiqL8fQIoPj5emTp1qm6b0NBQzfffrO8OM5ISV65cUQICAnRj/uCDD5SdO3fmJX2uXr2qhIeHK8HBwbpt9BI3eie1RP5O+M2dO1f5888/lStXrignT55UfvnlF6VNmzYuv3NKSlJCURTlu+++0x2HzWZTtmzZokpOnDlzRvnuu+90j0mLxeL0e8WspERh/p656+rVq0pgYKDuPp4wYYJy/Phxh9+nGzduKFFRUUq3bt1027377ru62xw5cqRuu+PHj2u2yc7OVlq2bKn7fuqdMDZjfIqiKH379tVtO3jwYGX9+vVKamqqoih/JyyPHDmi9OvXT7fN+PHjNbdz+fJl3TYWi0X54IMPlLCwMOXChQtKUlKSsn37dqf/N7j54Swp4e2x6klSQlHM+b0mKQEAMBpJCQCAU0WZlPjPf/6j+4dThw4dXLYfPXq0bvvg4GCPYlm6dKnLP1QtFotit9uVrl276l7Fn/vw9/d3eTVrQTk7GXrziQd36F3JfPN4srKy3I7NnaRE/pNs7tSz2+26yYFcV69edZmwEvn7Ku2QkBC33ndnJ/KuXLniMsEWHBys9OvXT3nrrbeUwYMH617FnPuYO3dukRwzw4YNc+vEbXBwsNK1a1eX70vPnj3d2q5W26JMSuTk5Cjt2rVz67119TmyWq1KUlKS7rbM+O4wIymhKIqybds2tz6n7iQ5J06cqLsddxOlnj5KUlJCUbSTBPkfAQEBSsuWLd3aX67u3jErKaEohft75q4jR464ddw0bdpUsdvtLus5S147S7R99NFHTuM8fvy4btt27drpJr6NHF+uc+fOuXUsulOnTZs2Tv/f4SyZUZCHs6SEt8eqp0kJRTH+95qkBADAaCQlAABOFWVSwtmVYB9++KHL9mvXrvXqhJceZ1cue3ri68SJE0X+3jibOsbTkzhRUVFO+5k8ebJHseklJQpyotFms2leGaglNjbW7URHQU/kKYrzY9nTR48ePYrsmElPT1c6d+5cKHGGhoa6nLYpl1b7okxKKIqiXLx40a2kk6vHtm3bXG7L6O8Os5ISiqI/3Zgnjw4dOrhMcm7YsKFA29D6fShpSYn09HSnV6178nDnt8DMpERh/p55Yv369YX22dVLXl+8eFE3ce1Ool1R9KdjEhHl888/N3V8+R04cMCtE/eutufq997VnWquHh999JHmnVyukhLeHKveJCWM/r0mKQEAMBoLXQMATONsIV93Fvl94okndF/TWhjRlbfffls+//zzAo0pMDBQtm/fLgEBAYW4p7QNHz680Pp6+OGHpWHDhrqvay0g7Y3169eL1Wr1uF1oaKhs3rzZ7ba1a9eWHTt2SMuWLb2O1WKxyObNm6V169Yu67Zv314+/vjjAu+fnj17yrx58wrcj56KFSvKsmXL5MUXXyxQP926dZNffvlF/Pz8iizWgqpUqZL89ttv0rFjR6/a22w2+e2336RZs2Yu65a0746C+Oc//yk///yz14twDxky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AAAAAAAAQ5CUAAAAAAAAAAAAhiApAQAAAAAAAAAADEFSAgAAAAAAAAAAGIKkBAAAAAAAAAAAMARJCQAAAAAAAAAAYAiSEgAAAAAAAAAAwBAkJQAAAAAAAAAAgCFISgAAAAAAAAAAAEOQlAAAAAAAAAAAAIYgKQEAAAAAAAAAAAxBUgIAAAAAAAAAABiCpAQAAAAAAAAAADAESQkAAAAAAAAAAGAIkhIAAAAAAAAAAMAQJCUAAAAAAAAAAIAhSEoAAAAAAAAAAABDkJQAAAAAAAAAAACGICkBAAAAAAAAAAAMQVICAAAAAAAAAAAYgqQEAAAAAAAAAAAwBEkJAAAAAAAAAABgCJISAAAAAAAAAADAECQlAAAAAAAAAACAIUhKAAAAAAAAAAAAQ5CUAAAAAAAAAAAAhiApAQAAAAAAAAAADEFSAgAAAAAAAAAAGIKkBAAAAAAAAAAAMARJCQAAAAAAAAAAYAiSEgAAAAAAAAAAwBAkJQAAAAAAAAAAgCFISgAAAAAAAAAAAEOQlAAAAAAAAAAAAIYgKQEAAAAAAAAAAAxBUgIAAAAAAAAAABiCpAQAAAAAAAAAADAESQkAAAAAAAAAAGAIkhIAAAAAAAAAAMAQJCUAAAAAAAAAAIAhSEoAAAAAAAAAAABDkJQAAAAAAAAAAACGICkBAAAAAAAAAAAMQVICAAAAAAAAAAAYgqQEAAAAAAAAAAAwBEkJAAAAAAAAAABgCJISAAAAAAAAAADAECQlAAAAAAAAAACAIUhKAAAAAAAAAAAAQ5CUAAAAAAAAAAAAhiApAQAAAAAAAAAADEFSAgAAAAAAAAAAGIKkBAAAAAAAAAAAMARJCQAAAAAAAAAAYAiSEgAAAAAAAAAAwBAkJQAAAAAAAAAAgCFISgAAAAAAAAAAAEOQlAAAAAAAAAAAAIYgKQEAAAAAAAAAAAxBUgIAAAAAAAAAABiCpAQAAAAAAAAAADAESQkAAAAAAAAAAGAIkhIAAAAAAAAAAMAQJCUAAAAAAAAAAIAhSEoAAAAAAAAAAABDkJQAAAAAAAAAAACGICkBAAAAAAAAAAAMQVICAAAAAAAAAAAYgqQEAAAAAAAAAAAwBEkJAAAAAAAAAABgCJISAAAAAAAAAADAECQlAAAAAAAAAACAIUhKAAAAAAAAAAAAQ5CUAAAAAAAAAAAAhiApAQAAAAAA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zJkzRyZMmKA6qZ/LYrFIjx49ZObMmVKpUqVC2ScXLlyQ7t27y6FDhxzKp02bJi+++KLH/R05csTheWBgoDRs2NBlu/r160tAQIDDwth//fVXoYwRAAAAAAAAAFCylcjpm3JyciQhIUFSUlI0T/ynpKTkPS5evKh6/fDhw/LAAw9Iv379nCYkRESio6Nl+PDhEhAQIPv27XNad+/evWKz2eS///2vbkJCRCQtLU2+/vprsdvtsnfv3gLvj9TUVGndurWEhYU5jL1r167Sr18/r/pMSEhweN6uXTu32wYFBan2IQAAAAAAAAAAJTIpURBJSUny2GOPqU66u5KWlibNmzeXo0ePar5+8eJFefbZZz3qNyYmRux2u2zZssXr8Zw/f17atGkjkZGRDuWvvPKKzJ071+sFpuPj4x2eV69e3e22iYmJDs9r1arl9fgAAAAAAAAAALeOEjl9k6+vr8yYMUNu3LghKSkpMmPGDIfXp06dmvfvxx9/3OG1Tz75RHUXg91ulxEjRkj9+vWlSpUqkpqaKnv37pW5c+c6nOxPS0uTL7/8Uj766CNVTP/5z38cpiwSEXn99dele/fuYrVa5eLFi3Ly5En56aefZPHixQ71Ro4cKREREarFo105e/astG7dWnW3x/Dhw2XmzJlerYWRq3///tKkSZO85+6uCXH27FlVgsRut3sdBwAAAAAAAADg1uGjKIpidhAFkZiYqFp82dmQ7rzzToekxKBBg+TTTz+VChUqqOpmZWVJr169ZPny5XllwcHBsnv3btX2KlWq5NDvypUrpUuXLpoxLFu2TJ599lmHsu3bt0tISEje86NHjzosGB0aGiobN27Me37mzBkJDQ1VrSExatQo+fDDDwuUkCiIXr16yZIlSxzKVq1aJZ06dTIlHrOEh4fLmjVrzA4DuKUkXDghrfo2kyb1WpodClDkRo75l9irt5QyPt7d8QjPXc64IGVqXJVBz71udiilyuHTu+Vw5GFRTltERHT/D+tpeWH2dSvHdCuMoTjGRKzFu7w4xsS+YMyMmX3BvmDMpWXMuUrknRLeSk1NdUgcWCwWmT59umZCQuTvOzImT57skJSIiIiQrKws8fX9v10XGxuruvtCLyEhItKjRw+x2+0OdxQcOXLEISnhTHJysrRo0UK1VsObb74pkydPNmXfKooikydPViUkbDabhIaG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tLQ0TjvttHj22WcT+zKtmZFpWqJspuNKH7WSfh8y2XPPPaOwsDCl7O677864LsBqb775Zvz4xz9OKWvTpk3i2/jpz1ReXl60aNGixj6lv+js0KFDyoia1dJfUlc3ddPYsWOjbdu2KT933XVXjX2pyfq8xp///Ocp2y+99FI89thjVbY5ZcqUOOSQQ1JeJOfn52ecMiwiuYZC+gLGdbF06dLE5zgi4uqrr64yvHznnXeiS5cuiWf+jjvuSNlO/7esutFOixYtip/97Gfxf//3f4l9mcKXunzmMq1Vk75+w5qeffbZ2H///RPPTETq4vCrZTOSJZs6mcr69+9fZT+//vrr6NevX+Lf7IEDByae0fU12gYAgOoJJQCAepc+hchq1113Xey6667Rt2/fePTRR+PVV1+NoUOHxsMPPxx9+/aNnXbaKX7zm98kXsadcMIJMXDgwIxtdu7cOTE3/T//+c+44IIL4qOPPqp8UTdt2rQYMmRIHH744fGf//wnpf5f/vKXjHOo1+WlekTE66+/nrKdafqcTN8U/+EPfxiPPfZYlJSUxLJly+Kjjz6Kv/zlL9G6deuYP39+Zb28vLy4//77U0YdNGjQIPHScvTo0fGLX/winnnmmfjwww/jnXfeiWuvvTb23XffxALf1fU10zfvs5nrP309jmxGV0RE9OzZM2V7/vz50blz53jxxRcr1zVYsmRJvPfee/HrX/86unTpkvIt8fz8/PjPf/6TGCmSaQRLNmsLpIdMVS12/vnnn6ds33vvvfHYY4/FsGHDEuuIjBw5MiZMmJDyk81i1DVZn9eY6Zk97bTT4u67747PPvssIr59Mf7hhx/GPffcEwcccEBi+rN//etfiW/KR3wbHqS7/vrr45lnnonXXnut1tO/rfbhhx9mLB8+fHj8+Mc/jnfeeSfKysrim2++iVGjRsVll10WHTt2TKz5MGjQoMT6JOmB3yuvvBJ//vOfU65lypQpceONN0a7du2q/Mxtt912ieury2cuUyhx+umnp/w79s0338SLL74Yp512Whx//PGJf2sjvl1Qe8WKFYk+ZbNWQzZ10tftiYj461//Gn379o3x48dHWVlZVFRUxPTp0+Oxxx6L/fffPzHS7o9//GPG6f2sJwEAUE8qAAA2AHfeeWdFRKz1z4UXXljxzTffVHuuiy66qNo28vLyqtx33HHHVSxfvjxju/n5+Sl133jjjRqve+7cuYlzTJs2LVFv4cKFifaz+cnLy6sYPXp0xnP36tWr1m2ll33xxReJdi+++OKUOueee26N92Hx4sWJtmfPnp3Vs7Nw4cJq/2Y1XdOECROyuj/XXnttVv0pKipKOe6hhx7Kqt6aP3feeWdK3TPPPDNRZ9y4cVn1pzrr+xqLi4vr9DmLiIr+/ftXef45c+ZUe2xVf9Oa3HbbbWv9b9AVV1xRUV5enmj73nvvrfO9yPTzwgsvVLZdl8/cihUrKgoKCmrdp6r+HSouLq5sO9PnedasWSnnz6bOatddd12d/x59+/bN+PeozfkBAFi3jJQAADYIffr0iTfffDMxFU+2CgsL48UXX4y//vWvNc7TfvXVV2dcOHe1TN8Gjojo169f/Pvf/44tt9wysW/mzJkpoxMiItq3b19jv9O/4ZyXlxf77LNPot6OO+4Yb7/9dhQUFGR9TwoKCuKVV16p8tu/AwYMiLy8vKzays/Pj2eeeSZxzzMtjp3+7eODDjqoxvbHjh2bOF8263GsvjejR4+u9bPToUOHeOedd2L//ffPuL8u36L+8ssvE9/2r2rER3VrIKQ/O+mjaSJSF0Ovq/V9jc8//3yVa1RU9TmLiHjkkUfiT3/6U5X7d99998SIpzXVdbHi9BEgP/3pT2t1/N133x2XX355xtEmPXv2rPLzm+ledOjQIT766KM466yzqrwHq9XlM9e4ceO4/PLLq9yfqU/XXHNNxjU3IiKaNWtW+Xum9XXSF+fOps5qF110UVx55ZU1XlO66667Lm666aaMf4/anB8AgHVLKAEAbDA6deoU48aNi9/+9rdZH1NcXByPPvpoTJo0KbGodVW23HLLuPvuu+Oqq67Kqv7RRx8do0ePjoEDB1a5GPTq6WhWa9OmTVYv/KdNm5ayfeSRR1ZZt7CwMEaOHFnjQsSFhYXx4IMPRklJSbUvvvfYY4947rnnqm0vLy8vBg4cGCUlJYnpYKpamHnSpEkp29ksnJx+H7Jdj2O1Vq1axbvvvptxqpdM9+f222+Pt956q8pAYsWKFYkpebK5junTpyfuX1UvyK+44oooKirKuG/N9RFWrlyZ6Eu3bt2qXZg8G7m4xt133z1ef/31lPVMqvPb3/42Zs6cGaeddlqNdf/xj39kLE9fKL420l/u9+nTJ1577bVqA5CIb9ewmTlzZmIh5TVttdVWMWLEiBoXNG/Xrl08+uijMXLkyGjbtm306tUrY73vfOc7lb/X5TMXEdG7d+8YNGhQjfXOOuusmD59elxyySWxzz77ZPx7rjmF19SpU1P2Zfo8Z1NntYYNG8Zll11W5ZRW6X7605/G5MmT4+KLL06Ztq6u5wcAYN1qUFFRxwlXAQDWoy+//DImTZoUEyZMiIkTJ8b48eOjYcOGkZ+fH/n5+dG+ffs47LDDUr4tXBdz5syJcePGxfvvvx9jxoyJBQsWRH5+fuy+++5RXFwcRxxxxAb57dkFCxbE2LFjY9SoUTFv3rxo3rx5tGzZMlq0aBH7779/rV/Kfvrpp/Hiiy/G559/Httss03sueee0bJly/je976X1XoQG4ry8vKYPHlyvP/++zF69OgYP358bL/99tGsWbMoKCiIww47rNoFpXOtrKwspk6dGlOmTImKiorYfvvtY//9948dd9wxUXfq1KmVo0H+/ve/x+9///v67n7WysvLo6SkJN5///0YO3ZsjB07NsrLyyu/nd65c+c49NBDY7vttqtVu1999VV8+OGHsXDhwthqq61i1113jVatWtXpmf3iiy9i1113TZTtvPPOsWLFivj3v/8d48aNi2nTpkXDhg1j//33j1atWsUhhxwSe+21V9bnKSsri5deeik++uijGD9+fCxfvjyaNWsWzZs3j+7du0erVq0Sx0ydOjVGjRoVy5cvj8aNG0dxcXHGenU1ZcqUeP311+Ojjz6KqVOnxi677BIFBQXxve99L4488sjE/fzmm29i5MiRMWvWrFi2bFk0b948Dj744Nhmm23WWZ+qsnjx4nj//ffjvffei3fffTdKS0tjr732ir322itatWoVxxxzTGy//fbrvR8AANSdUAIAADYCV111VeV0O59++mm0bNmyvru0SXn11VdTRtoUFhbGlClT6rtbAACwyTF9EwAAbODee++9ykCiZ8+eAon1YNSoUSnbnTp1qu8uAQDAJkkoAQAAG6iKioro379/HH744ZVl119/fX13a5OUvsh1x44d67tLAACwSTJ9EwAAbKCmTJkS++67b0REFBQUxHPPPRft27ev725tclav51FaWlpZNnLkyGoXigcAAOrGSAkAANhAzZo1K/Ly8qJ3797x3nvvCSTWk6lTp6YEEhER7dq1q+9uAQDAJqlR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H85YvlmFEvPmzUvZ7tq1a+Tl5VV7zN57750oSx+JkT5tU8S3QUWLFlV/m/fSSy+N++67r3J79913z+oaZs+eHYcffngikLj88surXP8BAAAAAAA2BJtVKLH//vvHnDlzKrebNm1a4zEjR46ssc6+++6bKDvyyCPjySefjAMOOCDjMSeeeGKceOKJter/rFmz4tBDD02EIFdffXVceumlObmHAAAAAABQV5tVKBFR/YiEsrKymD17dkyfPj0+++yzGDNmTFbrAjRv3jwKCgpi5syZlWUlJSVRXFwcxcXFceaZZ8Zhhx0Wbdu2jS22qNu8/5MnT84YSLRp00YgAQAAAADARmGzCyVWq6ioiFdeeSWGDx8eY8aMifHjx6eECrV18803R48ePRLlY8aMqVw7Ii8vL4455pjo3r17HHXUUbHPPvtk3X5VfZswYUK8/PLLcdRRR9XzHQUAAAAAgOo1rO8O1IcRI0ZEly5d4uijj47rrrsuXnrppbUKJCK+nY5pyJAh1dYpLS2NJ554Is4666xo3rx5dO7cOYYMGRLl5eVrde7evXsnFtoGAAAAAIANzWY3UqJv375x6623ZlW3uLg4jjnmmOjfv39W9Xv06BFz586NQYMGxe233x7z58+vtv6IESNixIgRcc4558Rtt92W9TUUFxdXjr6I+HYUxWWXXRZ///vf6+GOksk+++wT1157bU7O9f6cmtdGAQBq1rTpNnHNNdfUdzcAAAA2aQ0qKioq6rsTa2PWrFlRUFCQUlbVJT344INxxhlnJMrz8/Pj6KOPjgMOOCAKCwujefPmUVRUFE2aNIklS5bEtttum1J/xYoV0bhx42r7VVFRER988EEMHTo0hg0bFs8//3y19W+88ca44IILKrcnTZoUrVu3TtQbPHhwnHDCCXHAAQfEhAkTUva9/fbb0bFjx5zc9y+//DJ22GGHlLIRI0bEIYcckpPz8//84dY34pc/+UFs2bhu65XAxuKZ4eNjp+2bRucDWtR3VzYr9z8zOrp+v2U033On+u4KrFdzvyiNkeNK4sKexfXdFQAAgE3aZjVS4pJLLkmUPfDAA9GzZ89o1CjzrVi+fHmdztWgQYNo3759tG/fPs4///xYuXJljBo1Kl5++eW49957E9NF3XTTTSmhRCavvPJKHHnkkRERcccdd0SXLl1S9p9xxhkxbty42Hrr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xBPx2GOPxSuvvJLYn5+fH+3bt48DDzwwLrroothxxx3rtb8AAAAAAGx4NvqREl988UU0a9Ysdtttt9htt92iZcuW9d2lTc7IkSPje9/7XvTu3TtjIBERMX/+/HjllVfi+uuvj9atW8fLL79c390GAAAAAGADs9GHEsuXL4+ZM2fG/PnzY/78+SmjC1h7r776ahx88MG1uq/z58+Po48+Oq644or67j4AAAAAABuQjT6UYP2ZNWtW9OjRI+O+vLy8OO644+JXv/pVdOzYMWOdK6+8Mt599936vgwAAAAAADYQ1pSgSn/729+itLQ0payoqCiGDBkSbdq0iYYN/1+m9emnn8ZvfvObGDZsWEr9c845J95+++3YYost6vtyAAAAAACoZ0ZKkNGKFSvi7rvvTikrKCiIoUOHxne+852UQCIiYt99942XX345OnXqlFI+evToGDp0aH1fDgAAAAAAGwAjJSJizpw5MX369Jg+fXp89dVXseuuu8Yee+wRe+yxR+y1117RoEGDWre5cuXKmD59ekydOjVKSkqiYcOG0bp162jdunXssssu9X3JNRo6dGhilMTzzz8fBQUFVR6zxRZbxD333BOtW7dOKR87dmwcddRR9X1JAAAAAADUs40ylCgrK4sWLVrEihUrYtmyZYn9u+22W+Xv//znPzOui/DNN9/Ek08+GTfccEN88MEHVZ6rqKgozj333DjttNOyChOWLVsWt99+e1x55ZWJl/qr5eXlxUknnRQ33XRTbL/99uvknixatCh69OgREyZMSCkfMGBAnHnmmbVu7+OPP07ZbtOmTbRr167G41q1ahWFhYUpC2O///776+QaAQAAAADYuG2U0zeVl5fHzJkzY/78+Rlf/M+fP7/yZ/HixYn9EydOjP322y969epVbSARETF58uQ477zzorCwMMaNG1dt3bFjx0ZRUVH84Q9/qDKQiIgoLS2N+++/P4qLi2Ps2LFrfT8WLlwYRx55ZAwfPjzl2k844YTo1atXndqcOXNmyvbRRx+d9bFt27ZN3EMAAAAAANgoQ4m1MWfOnPjBD36QeOlek9LS0ujSpUtMmjQp4/7FixfHySefXKt2S0pKori4OF577bU6X8+CBQuie/fuMWbMmJTy3/72tzFo0KA6LzA9Y8aMlO0999wz62NnzZqVsr3PPvvU+foAAAAAANh0bJTTNzVq1CgGDhwYK1asiPnz58fAgQNT9l9//fWVvx988MEp+/7xj38kRjEUFxdHv379olWrVrHzzjvHwoULY+zYsTFo0KCUl/2lpaVx5513xt/+9rdEn37/+9+nTFkUEXHhhRdGjx49Ij8/PxYvXhzTpk2Lxx9/PAYPHpxS7/zzz4/Ro0cnFo+uyeeffx5HHnlkYrTHeeedFzfddFOd1sJY7YwzzogDDzywcjvbNSE+//zzREBSXFxc534AAAAAALDpaFBRUVFR351YG7NmzUosvlzdJW233XYpocRZZ50VN998c2y11VaJumVlZfHTn/40nnrqqcqyDh06xKhRoxLn23777VPa/c9//hPHH398xj4MGTIkTj755JSyN998Mzp16lS5PWnSpJQFo7t16xZDhw6t3J43b15069YtsYbEBRdcEDfccMNaBRJr46c//Wk88cQTKWXPPvts/PjHP66X/tSXESNGxIsvvpiTc7316Utx08A7o9EWW9b3ZcN6NeKTZ2K7rXeK7zbrXN9d2ayMmPxMzHm3NCq+2qrKOjX9b87a7s/FOVzDhtGHzeEaNoQ+bA7XsCH0YXO4hg2hD/q46fRBH/VRHza9a9gQ+qCP+qgPG14fIzbSkRJ1tXDhwpTgIC8vL2688caMgUTEtyMy+vfvnxJKjB49OsrKyqJRo/9366ZOnZoYfVFVIBERcdJJJ0VxcXHKiIKPP/44JZSozty5c+Owww5LrNXwpz/9Kfr3718v97aioiL69++fCCSKioqiW7du9dKn+nbttdfm5DxdehxQ35cKbMLKy8vjoYceik/GzFj7xgAAAIDNxhVXXBGXX355onyzCiXmzZuXst21a9fIy8ur9pi99947UZY+EiN92qaIb4OKFi1aVNnupZdeGvfdd1/l9u67757VNcyePTsOP/zwRCBx+eWXxxVXXJGbG5lm4cKF0bdv33jkkUcS+x588MFo2rRpvfQLAAAAAIANy2YVSuy///4xZ86cyu1sXpaPHDmyxjr77rtvouzII4+MJ598Mg44IPO32E888cQ48cQTa9X/WbNmxaGHHpoIQa6++uq49NJLc3IP0z3++OPRp0+fxEiRiG+Dkh/84Af10i8AAAAAADY8m1UoEVH9iISysrKYPXt2TJ8+PT777LMYM2ZM3HXXXTW22bx58ygoKIiZM2dWlpWUlERxcXEUFxfHmWeeGYcddli0bds2tthiizr1e/LkyRkDiTZt2tRLIPHBBx/E7373uxg+fHjG/bfcckv83//9X877BQAAAADAhmuzCyVWq6ioiFdeeSWGDx8eY8aMifHjx6eECrV18803R48ePRLlY8aMqVw7Ii8vL4455pjo3r17HHXUUbHPPvtk3X5VfZswYUK8/PLLcdRRR+Xkvn3++edxxRVXxO23355xf5s2beK+++6Lgw46KCf9AQAAAABg47FZhhIjRoyIP/7xjzFixIh11uaJJ54YQ4YMiZNOOqnKOqWlpfHEE09ULgbdqVOn6NevX5x44onRsGHDOp+7d+/eMWHChBrXx1hbQ4YMiV/+8pcZp2qKiBg4cGCce+650bhx4/XaDwAAAAAANk6bXSjRt2/fuPXWW7OqW1xcHMccc0z0798/q/o9evSIuXPnxqBBg+L222+P+fPnV1t/xIgRMWLEiDjnnHPitttuy/oaiouLK0dfRHw7iuKyyy6Lv//97+vlnpWWlka/fv3innvuybi/d+/ecdVVV8Wee+65Xs6/sbrmmmtycp7XP3m+vi8V2MT9/Bc/j4rjtqpyf0VFRbXHr+3+XJxjc+jjpnANG0If9HHD2L8h9EEfN4z9G0If9FEfN6Q+bA7XsCH0YVPo46ZwDRtCH/Rxw9i/IfRBH7M/R0REg4psa26gZs2aFQUFBVld/IMPPhhnnHFGojw/Pz+OPvroOOCAA6KwsDCaN28eRUVF0aRJk1iyZElsu+22KfVXrFhR42iAioqK+OCDD2Lo0KExbNiweP756l8c33jjjXHBBRdUbk+aNClat26dqDd48OA44YQT4oADDogJEyak7Hv77bejY8eO6/T+Ll68ODp16pQ4V0RE9+7d48Ybb4x27dqt03NSO9e/eF78qP0vo9EWW9Z3V2C9GvHJM7Hd1jvFd5t1ru+ubFbe/uTZ6NrquGi5a9v67goAAACwCdisRkpccsklibIHHnggevbsGY0aZb4Vy5cvr9O5GjRoEO3bt4/27dvH+eefHytXroxRo0bFyy+/HPfee29ijYibbropJZTI5JVXXokjjzwyIiLuuOOO6NKlS8r+M844I8aNGxdbb731OrlfK1eujFNPPTURSOTn58ett94ap5xyyjo5DwAAAAAAm4e6L2SwkZk2bVoiCLj33nvj9NNPrzKQiIgYNWpUjW1PnTo1Pvjgg8qf8vLyRJ3GjRtHp06d4sorr4ypU6dGv379UvbPnDkzFixYUOU5unXrVhlIRER07tw5evfunVJn8uTJMWDAgHV2zy655JJ46aWXUsq6dOkS48aNE0gAAAAAAFBrm00oMX78+ETZT37ykxqPGz58eI11fvzjH1eOimjfvn2UlJRUW79Ro0Zxww03JMo/+eSTWl3TgAEDEotbX3HFFfHhhx+u9f1asGBBoo/FxcXx/PPPx+67777W7QMAAAAAsPnZbEKJLbbYIlG21VZbVXvMrFmz4uGHH66x7QMPPDBl+80336xTH3fbbbda1d95550zLtrdu3fvKCsrW6v79fTTT6ds5+XlxfPPP58IQQAAAAAAIFsbfSjRoEGDRFmmKZfatGmTKHvssceqbHfs2LFRXFycmPIpIrmQ9kEHHZSyffXVV8fcuXOr7Xf6ufPz86NFixa1vv5evXol1pYYPXp03HLLLXW+pxERDz30UMr2hRdeaIQEAAAAAABrZaMPJXbeeedE2e9+97t48sknY9iwYbFo0aKIiGjWrFniW/69e/eOW265JZYtW1ZZNmnSpLjyyiujuLg45s+fn/GcI0aMSAkmfvSjH6XsLykpiaKionj66acTC2XPnTs3rr322vjFL36RUp7NVFKZNGjQIAYNGpQoP//882PKlCl1anPZsmWJaasuu+yyaNmyZZ1+/vCHP9SpHwAAAAAAbFoarX0T9WurrbaKwsLClHUcRo4cWbkQ8z333BO/+tWvokGDBnHjjTfGb37zm5TjzzvvvDjvvPOioKAg46iITLp16xYREYMHD45TTjklCgsL47rrros//elPlXVKS0vjxBNPjIiIwsLC2HvvvWP27NkxefLkRHv5+flx3XXX1fketGnTJv7yl7/E1VdfnVJ+1llnxauvvppxNEl1pk+fnrG8prUyatseAAAAAACbl41+pERERN++fbOq16dPnzjuuOMy7ssUSOTn58f//ve/uO222zIes2TJksrfzz///OjYsWPGeiUlJTF8+PCMgURExJAhQ2KnnXZaq3tw8cUXR0FBQUrZsGHD4v777691W3UNHwAAAAAAoDqbRChxzjnnxAUXXFBjvQYNGsSTTz4Z/fv3r7Fuv379YtKkSdG1a9f4+c9/nli3Id2WW24Zr7/+elxxxRVZ97t3794xe/bs6Ny5c2Jf48aNU7abNGlSbVtNmzaNu+66K1F+8cUXR3l5ea3u55dfflmr+jXZeuut12l7AAAAAABsnBpUpK/avBFbtGhRfPrppzF37txo0qRJ7LnnnlFUVBSNGiVnqZo2bVq88cYbMX78+Pj0008jLy8v9tlnn2jbtm0ce+yx0bRp05T6y5cvj9GjR8eMGTPi66+/jmbNmkWnTp0S61RERHzxxRfx1ltvxWuvvRYTJ06Mr776KlatWhWFhYXRsmXLKCwsjA4dOkTbtm3r+5axCbj+xfPiR+1/GY222LK+uwLr1YhPnonttt4pvtus89o3Rtbe/uTZ6NrquGi5q//NAgAAANbeRr+mxJp23HHH6NChQ1Z1mzdvHs2bN8+67a222irjiIZMdtlllzj++OPj+OOPr+9bAgAAAAAAG4xNYvomAAAAAABgwyeUAAAAAAAAckIoAQAAAAAA5IRQAgAAAAAAyAmhBAAAAAAAkBNCCQAAAAAAICeEEgAAAAAAQE4IJQAAAAAAgJwQSgAAAAAAADkhlAAAAAAAAHKiUX13AFg7DSLinSkv1nc3YL1bsvyrKFu1IkZM/k99dwUAAACAOmpQUVFRUd+dAOpu6hcf13cXICfmfjk9IiJ2337v+u7KZqnFLq3ruwsAAADAJkAoAQAAAAAA5IQ1JQAAAAAAgJwQSgAAAAAAADkhlAAAAAAAAHJCKAEAAAAAAOSEUAIAAAAAAMgJoQQAAAAAAJATQgkAAAAAACAnhBIAAAAAAEBOCCUAAAAAAICcEEoAAAAAAAA5IZQAAAAAAAByQigBAAAAAADkhFACAAAAAADICaEEAAAAAACQE0IJAAAAAAAgJ4QSAAAAAABATgglAAAAAACAnBBKAAAAAAAAOdGovjsArJ2vpz9b310A1sI3n4+KxtvtG1tstVN9dwWooy23bxVbbl9U390AAADYKAglYCM3+389o+nO36/vbgB1tPTzkdF0lx9ENGhQ310B6mDFkulRcMyL9d0NAACAjYZQAjYBe7a/Kho2alrf3QDqYPJLh8bu37k4Gm29a313BaiDktdOqe8uAAAAbFSsKQEAAAAAAOSEUAIAAAAAAMgJoQQAAAAAAJATQgkAAAAAACAnhBIAAAAAAEBOCCUAAAAAAICcEEoAAAAAAAA5IZQAAAAAAAByQiixgZoxY0a0bNkymjVrFs2aNYtf//rX9d2lSt98801Mnz49Jk2aFF999VV9dwcAAAAAgI1Eo/ruAJktXbo0SkpKKrenTp1ar/0ZOXJkPPLII/H444/H/PnzU/bl5eVF27Zt46CDDop+/fpF8+bN67WvAAAAAABsmDb6kRJffPFFNGvWLHbbbbfYbbfdomXLlvXdpU3K0qVLo2/fvnHwwQfHLbfckggkIiJKS0tj5MiRcfPNN0eLFi2ib9++8fnnn9d31wEAAAAA2MBs9CMlli9fHjNnzqzczvTSnLpZtWpV9OjRI1566aVaHXfrrbfGuHHjYtiwYdGo0Ub/iAEAAAAAsI5s9CMlWH/++te/VhlItGnTJnr27BlHH3105OXlJfa/8cYbcdlll9X3JQAAAAAAsAERSpDR119/HX/+858T5TfddFMsWbIkxo8fHw8//HD897//jVmzZsU111yTqHvdddfF7Nmz6/tSAAAAAADYQAglyOjf//53ouyhhx6K3/3ud9G0adOU8ry8vLjkkkvilltuSRzz0Ucf1felAAAAAACwgTDhf0TMmTMnpk+fHtOnT4+vvvoqdt1119hjjz1ijz32iL322isaNGhQ6zZXrlwZ06dPj6lTp0ZJSUk0bNgwWrduHa1bt45ddtmlvi+5Rk8++WTKdq9eveLnP/95tcece+658fe//z1KSkoqyz788MM46qij6vtyAAAAAADYAGyUoURZWVm0aNEiVqxYEcuWLUvs32233Sp//+c//xk9evRI1Pnmm2/iySefjBtuuCE++OCDKs9VVFQU5557bpx22mlZhQnLli2L22+/Pa688sooLS3NWCcvLy9OOumkuOmmm2L77bdfJ/dk0aJF0aNHj5gwYUJK+YABA+LMM8+sdXtTpkxJ2T7ttNOyOu773/9+SigxadKkdXJ9AAAAAABs/DbKUKK8vDxmzpxZ5f758+dX/r548eLE/okTJ8ZRRx1VbRurTZ48Oc4777y45JJL4o033oj27dtXWXfs2LFx/PHH19huaWlp3H///fH666/Hk08+GQcccMBa3Y+FCxdG9+7dY8yYMSnlffr0iV69etWpzRkzZqRsFxUVZXXcnDlzUrZ32mmntbo2AAAAAAA2HRtlKLE25syZEz/4wQ+qHMVQldLS0ujSpUuMHj06WrVqldi/ePHiOPnkk7MKOlYrKSmJ4uLiGD58eBx22GF1up4FCxbEUUcdlQgkfvvb38att94aDRvWftmQioqKOOaYY+Lrr7+uLNtrr71qPO6bb76JN954I6Us2zADAAAAAIBN30YZSjRq1CgGDhwYK1asiPnz58fAgQNT9l9//fWVvx988MEp+/7xj38kAoni4uLo169ftGrVKnbeeedYuHBhjB07NgYNGpTysr+0tDTuvPPO+Nvf/pbo0+9///uUaYsiIi688MLo0aNH5Ofnx+LFi2PatGnx+OOPx+DBg1PqnX/++TF69OhaBwiff/55HHnkkYnpp84777y46aab6rQWRkREgwYNEn2sSVlZWfzf//1forxTp0516gMAAAAAAJueBhUVFRX13Ym1MWvWrCgoKEgpq+6Stttuu5RQ4qyzzoqbb745ttpqq0TdsrKy+OlPfxpPPfVUZVmHDh1i1KhRifNtv/32Ke3+5z//ieOPPz5jH4YMGRInn3xyStmbb76Z8gJ/0qRJ0bp168rtbt26xdChQyu3582bF926dUusIXHBBRfEDTfcUOdAorbmzJkTH374Ydx8883x/PPPp+z77W9/G7fffntO+rGhKSkpifvuuy8aNGgQDRs2rPxZc7uq32uzr2HDhvHlO7+MPue/HA0bNa3vywbqYPJLh0bhYUOi0da71ndXgDooee2UKPjhf2PL7Y0OZdOz+v9Xrfn/r+pati7a2JDK6vv8rnHju55N9Vyb0/kPOeSQ+NGPfhQArL2NcqREXS1cuDAlOMjLy4sbb7wxYyAR8e2IjP79+6eEEqNHj46ysrJo1Oj/3bqpU6cmRl9UFUhERJx00klRXFycMgrj448/znpUwdy5c+Owww6LyZMnp5T/6U9/iv79+6/3+3jEEUfE4sWLY+bMmSnrd6zplFNOyUlfNlRffPFFXHPNNTk51+ndG0ef+r5gANhMfbP8m+jevXvMWtg4pTzTl2Sq+uJMtnVzUbah9WdT7/fGcC0AfKtjx47x1ltv1Xc3ADYqbdq0iZ49eybKN6tQYt68eSnbXbt2jby8vGqP2XvvvRNl6f+xnj5tU8S3QUWLFi2qbPfSSy+N++67r3J79913z+oaZs+eHYcffngikLj88svjiiuuyMl9HD16dLVrcrRp0ybuvffe2HbbbXPSnw1ReXl5zs6Vo0ExAEAVpk+fHtPmrX07AMCGa+TIkTFy5Mj67gbARuXhhx/OWL5ZhRL7779/zJkzp3K7adOap7vJ5n9w9t1330TZkUceGU8++WQccMABGY858cQT48QTT6xV/2fNmhWHHnpoIgS5+uqr49JLL83JPczGhAkTYs8994ynn346unXrVt/dqRe5DCUaCiUAAAAAgI3EZhVKRFQ/IqGsrCxmz54d06dPj88++yzGjBkTd911V41tNm/ePAoKCmLmzJmVZSUlJVFcXBzFxcVx5plnxmGHHRZt27aNLbbYok79njx5csZAok2bNjkPJE466aSYN29ezJs3Lz755JOMoyZKS0vjiCOOiGHDhsXhhx+e0/5tCIyUAAAAAABI2uxCidUqKirilVdeieHDh8eYMWNi/PjxKaFCbd18883Ro0ePRPmYMWMq147Iy8uLY445Jrp37x5HHXVU7LPPPlm3X1XfJkyYEC+//HIcddRRObt3a047FfHtWh2PPPJI/P3vf0+EJmeffXZMmDChzmHMxiqX8/E2lEoAAAAAABuJhvXdgfowYsSI6NKlSxx99NFx3XXXxUsvvbRWgUTEt9MxDRkypNo6paWl8cQTT8RZZ50VzZs3j86dO8eQIUPW+lv1vXv3rnaNh/Vtp512inPPPTfGjBkTbdq0Sdk3efLkeP755+utb/XFSAkAAAAAgKTNbqRE375949Zbb82qbnFxcRxzzDHRv3//rOr36NEj5s6dG4MGDYrbb7895s+fX239ESNGxIgRI+Kcc86J2267LetrKC4urhx9EfHtKIrLLrss/v73v9fDHf1/tt9++/jPf/4T++23X0r56NGj4/jjj6/XvuXaLrvsEldffXWUl5dHRUVFlJeXV/t7XeuVl5dH4TZP1fflAsBmq0H4dgAAAEBtNKjI5Twz68GsWbOioKAgpayqS3rwwQfjjDPOSJTn5+fH0UcfHQcccEAUFhZG8+bNo6ioKJo0aRJLliyJbbfdNqX+ihUronHjxtX2q6KiIj744IMYOnRoDBs2rMbRAjfeeGNccMEFlduTJk2K1q1bJ+oNHjw4TjjhhDjggANiwoQJKfvefvvt6Nix41rf008++SRl5EiLFi2iefPmWR/fsmXLlGmcTj311Hj00UfXul9kNvmBvNi32wvRsFHNC7cDG57JLx0ahYcNiUZb71rfXQHq4ONXT4g7RnSIhcu2i4iIBmlDGBtkGNJY17INta2Nqa+b63WvTfsAAFBXLVq0iJ49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2LCUYwoKCupUJ926fJ7rcn4AADZuQgkAgDXccsstiZdrjzzyyFq1uXDhwop77rmn8ue+++6r8qX8Bx98UFFUVFTjC8k1fwYNGlTt+dPbGzVqVMVPf/rTrNrOy8urmDVrVrXtl5eXVzzwwAPVhhHpPyeccELGtnr27JlSL5uX4EuWLEm0P2XKlES9o48+OqXOm2++WfHHP/4xY/9WhzHLly9P7Js3b15F9+7dMx63fPnyxHmfeOKJGl96r/lz6qmnVnz11VdVXu95552XUv/ee++tuPLKK7Nu/6WXXqrx/lX1c+21167VZyFbBQUFKed9/fXXK0488cSs+njcccdVfP311zU+s7W5Z6t/evfuXWWba/usfPzxx7X+7EdExYQJE6rs01//+tfEs1WXOmta189zbc8PAMDGTygBALCG9G/+tmnTpqK8vDwn5x4yZEitX0iu/rnqqqsytrl48eJE3cLCwlq1fdxxx1XZ54ULFyZe9mf788orryTaS38Znc03rd9+++1EkJL+N1u1alUiNDn22GOr7Nvql9pjxoxJfIu7TZs2VX4zfE0rV66sOP/88+t0b6p7MZs+qqM2L4hX119z5E/6/atNoLE+zJs3b62f2a5du1bZ/vLlyxPhV21+qgop1+ZZef3112sV6qX/G7Vs2bKMfTrppJNS6v7973+vU531+Txne34AADYd1pQAAPj/ffzxx4m1H84777ycLPI7duzYOOmkkxLlZ555Zhx88MHxve99L5YuXRpvvvlm/Pe//40RI0ak1LvsssuiZ8+e0bJly5Ty999/P9FmSUlJ5e/dunWLI444Ivbcc8+YNm1aPPvss4l78Oyzz2bsc3l5efzyl7+Ml156KaW8oKAgfve738X3v//9aNSoUXz66adx++23JxZQ/stf/hJHHnlk5fbcuXNj5syZKXWymVv+vffeS9nOtDDzJ598EqWlpSllzz//fKKtvLy82G+//WKbbbaJiEjci/T+rXlcp06dUsouv/zyGDhwYKLuOeecE8XFxbHzzjvH2LFj43//+19iod/HHnssevfunXJ/IiKWLVuWuI/z58+v/L2oqCh+9rOfxd577x1ffvll/O9//0tc5/z582PKlCmV97ZZs2Zx/fXXR0TErbfemnKNHTp0SHkuDzrooBr/Hmurpmf23HPPja5du8Yuu+wSc+bMiXvvvTde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eNH+8MMPpwQeS5curdPUKOlz+kckpwgqLCxM3KPqfPXVVykviCMi+vXrVzm1TkTEtGnTUvavOQ1VJgMHDoyXXnopUZ5p2pu6rMOQaT2O/fffv8bj0qeyev7552s85quvvkoshn7qqacm1r1In38/m5EbmV6YZwqn0p+7goKCdbLQe20sXrw4cd+fffbZxDRn6V588cX45z//mVLWr1+/2G677Sq307+Vf+qpp1bb5rJly+KCCy5IlGcKtOryrKS/oC8qKqpxRNbIkSPj6quvTinLy8tLfB4jkkFUpnVfsqmzPp/nbM4PAMCmSygBABARe+65Zxx99NGJ8vPPPz/+/Oc/x/Lly6s8tqysLO68885o1apVYh2Jvn37JkY2RCQXfY2I+P3vf5+YZmZN1157bfz2t79NKbvuuusSU+2k9yEvLy9atGhR4z1In9O/Q4cOifAk/YXuiBEj4l//+lfG9r788ss4+eSTEwHJH/7wh5TtFStWpGwPHz48Pvvss0R75eXlMWDAgMTxERHdu3ePLbbYIqVs2rRp62Qdhi5dumS1HkfXrl1TtkePHp2YZmtNn332WZx44omJb6Bfd911KdtlZWWJUQTZhEyffPJJoux73/teomzSpEkp29WNqikrK4sDDzww2rZtW/lz1lln1diXmrz//vsZy2+88cYqj3nwwQfjRz/6UUpZUVFR5bRgq6WPQEq/3jVNnDgxOnbsGA888EBiX6ZAqy7PysqVK1O258yZkxg5tVpZWVn0798/4xofhx56aEoYuVr6VFyZ/p7Z1Flfz3O25wcAYNMllAAA+P/dfvvtGcuvu+662HXXXaNv377x6KOPxquvvhpDhw6Nhx9+OPr27Rs77bRT/OY3v0m8AD/hhBNi4MCBGdvMy8tLvOAfPXp0/OQnP4mRI0dWLgq9YMGCePnll+P000+PSy+9NKV+ly5dMr6gT39R2rVr14wvL9Nls9jxCSeckCg7/fTT45ZbbokPPvggli9fHiUlJXHPPfdEs2bNEt/Uv++++1JGSUR8+yJ5TaWlpdGjR4946KGHYsyYMTFu3Li45557okOHDnHxxRdn7Humb1rXdR2Guk6VdNJJJyXKjj/++Bg0aFBMmzYtKioqoqysLD7++OO44YYbonnz5omRHM8880xibv0JEyYk2s1mEej09SSKiooyrguQvk7Iq6++GnfffXcMHTo0EQ5NnDgxxowZExMmTKj8SQ+V6iK9r6tdc801cd5558WUKVOivLw8Fi1aFEOHDo2f/exnccYZZyTqDx48OPE3Tv9c/vnPf45HH300ysvLI+LbsGvUqFHxxz/+Mdq0aZMI9VbbbrvtEtO51eVZKSsrS/TvF7/4RcoUWgsWLIgHH3wwunTpEpdccknGdnbZZZdYtWpVSp/mzZtX41Rc2dSJWH/Pc7bnBwBgE1YBAEClO++8syIi1vrnwgsvrPjmm2+qPddzzz1XbRv5+flV7issLKz47LPPMrbbq1evlLrXXnttVtdeVFSUctxDDz2Usd6xxx5bp3ty5513ZmzvnnvuWev7/Z///CfR7sUXX5xS59xzz83qPnTo0CHluCeeeCLr56d79+51vobBgwdnbPPee+9NqdetW7es+nLeeeelHNenT5+M9fr27Vtln3r27JlS97777kvUue2227K+P1U55ZRT1voZeO655zK2nf55WPMnLy+vys9XVcfMmzdvrZ6Vjz/+uNrrqKpPVZX/8Y9/rGz7hRdeSFxHumzqrM/nuTbnBwBg02SkBADAGvr06RNvvvlmxrnas1FYWBgvvvhi/PWvf42tttqq2rrHHnts3HHHHVXur2qh365du8aoUaNi7733zrg/fZ2H9OmdMvnyyy8T8+NXtf7C4MGD44c//GGt7stdd90Vffr0ybjvjDPOqNVCt0888US0adMmpSzTN63T70M26zAsW7Ys8e332nyL+8knn4zjjjuuVvcmPz8/nn322YwLpEdEjBo1KmV7XS5yHZF5Sqeqrj393kRk93zV5LXXXkvZPvPMM7M+Nj8/P95555049thjM+6vanRNRGScLq1nz57x7rvvRkFBQcZjdt5554io+7PSqlWr6NmzZ9Z9ys/Pj6effrrKfyv22muvyt/TR5xkWpw7mzqrrY/nuTbnBwBg0ySUAABI06lTpxg3blxi/YbqFBcXx6OPPhqTJk1KLGpdnbPOOiteeOGFrOoWFRXFE088EUOHDq18MZpuxYoViTnds3lROn369JTtvLy82G+//TLWbdq0aTz11FPRq1evatvMy8uLq6++OhYuXBi//vWvq6y3xRZbxL/+9a8ag47zzjsvZsyYET/5yU9SpjTKz8/P+AI5fe2AbO7DrFmzEteQzXocq2233Xbx1FNPxUUXXVRj3by8vLjwwgtj0qRJ8eMf/7jKelOmTEnZzjYESF9QuaqQ6ZRTTokuXbpk3Jd+rvS+RER897vfzfr+ZDJz5sxEAHfLLbfELbfcUuP9+9vf/hYlJSXVBk5t2rSJ119/PfLz86tt74c//GGMHDkyHn744dhxxx3jd7/7XaLO0UcfXbl2ydo8K3fddVecc8451dbJz8+Pa6+9NkpKSuKEE06Ibt26ZXzO1/y7pn/2My3OnU2d1dbH81yb8wMAsGlqUFGRNjEqAACVvvzyy5g0aVJMmDAhJk6cGOPHj4+GDRtGfn5+5OfnR/v27eOwww6L3Xfffa3O89VXX8WHH34Y77//frz77rsxbdq02HHHHWP33XeP/fffP7p16xZt2rTJam2IXFq6dGl88MEH8d5778WkSZNi9913j5YtW0ZhYWG0adMmttlmm1q1t2DBgnj++efj008/jSZNmsROO+0U++67b7Rr1y523XXX+r7cWpk1a1aMHTs23nvvvXjvvfeiUaNGUVBQEHvttVcceOCBcdhhh2W1gHauTJw4MWbMmBErVqyIvLy8aNmyZcaX4OXl5bHPPvvEzJkz47jjjotnnnlmrc77zDPPpKxV0q5duxg3blxEfPs8PP744/Hpp5/G9OnTY4cddog2bdpEq1at4rDDDottt9026/MsWrQoXn755crP8tZbbx3NmjWL/fbbL4499tiMz9eYMWNiypQpsWjRosjPz4+OHTuu9Wd9TSNHjoz33nsvPvroo/j8889jjz32iIKCgujSpUt07NgxGjZM/Q7ZwoUL46233opFixbFqlWrYv/994/vf//7iUXe14eN7XkGAGDDJZQAAACy9r///a9yuq0HHnggTj/99LVq77LLLourr766cvvss8+Of/7zn/V9mQAAwHpi+iYAACArixYtqpyKq6CgoMp1A2qjLmt/AAAAGy+hBAAAUKOnnnoqOnbsWLkmwK233hpNmjRZqzbLyspi2LBhKWVVrX0BAABsGkzfBAAA1Gi33XarXJD60UcfjVNPPXWt25wwYUK0bds2pWzlypXRqFGj+r5cAABgPTFSAgAAqNaSJUti2bJlcdxxx8W77767TgKJiIj33nsvZbtLly4CCQAA2MT5L34AAKBa22yzTSxcuHCdBwajRo1K2T7kkEPq+1IBAID1zEgJAACgRutjBMNbb72Vsm2RawAA2PQZ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" sr-org-src="https://tenthousandmeters.com/blog/python_bts_12/concurrency.png"></div></p><p></p><p>It's crucial to realize that you can write concurrent programs without any special support from the language. Suppose you write a program that performs two tasks, each task being represented by a separate function:</p><p></p><div><pre>def do_task1():
    # ...

def do_task2():
    # ...

def main():
    do_task1()
    do_task2()

</pre></div><p></p><p>If the tasks are independent, then you can make the program concurrent by decomposing each function into several functions and call the decomposed functions in an interleaved manner, like so:</p><p></p><div><pre>def do_task1_part1():
    # ...

def do_task1_part2():
    # ...

def do_task2_part1():
    # ...

def do_task2_part2():
    # ...

def main():
    do_task1_part1()
    do_task2_part1()
    do_task1_part2()
    do_task2_part2()

</pre></div><p></p><p>Of course, this is an oversimplified example. The point here is that the language doesn't determine whether you can write concurrent programs or not but may provide features that make concurrent programming more convenient. As we'll learn today, <code>async</code>/<code>await</code> is just such a feature.</p><p></p><p>To see how one goes from concurrency to  <code>async</code>/<code>await</code>, we'll write a real-world concurrent program – a TCP echo server that supposed to handle multiple clients simultaneously. We'll start with the simplest, sequential version of the server that is not concurrent. Then we'll make it concurrent using OS threads. After that, we'll see how we can write a concurrent version that runs in a single thread using I/O multiplexing and an event loop. From this point onwards, we'll develop the single-threaded approach by introducing generators, coroutines and, finally, <code>async</code>/<code>await</code>.</p><p></p><h2 id="sr-toc-1">A sequential server</h2><p></p><p>Writing a TCP echo server that handles only one client at a time is straightforward. The server listens for incoming connections on some port, and when a client connects, the server talks to the client until the connection is closed. Then it continues to listen for new connections. This logic can be implemented using basic socket programming:</p><p></p><div><pre># echo_01_seq.py

import socket


def run_server(host='127.0.0.1', port=55555):
    sock = socket.socket()
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, port))
    sock.listen()
    while True:
        client_sock, addr = sock.accept()
        print('Connection from', addr)
        handle_client(client_sock)


def handle_client(sock):
    while True:
        received_data = sock.recv(4096)
        if not received_data:
            break
        sock.sendall(received_data)

    print('Client disconnected:', sock.getpeername())
    sock.close()


if __name__ == '__main__':
    run_server()

</pre></div><p></p><p>Take time to study this code. We'll be using it as a framework for subsequent, concurrent versions of the server. If you need a reminder on sockets, check out <a href="https://beej.us/guide/bgnet/">Beej's Guide to Network Programming</a> and the <a href="https://docs.python.org/3/library/socket.html">docs on the <code>socket</code> module</a>. What we do here in a nutshell is:</p><p></p><ol>
<li>create a new TCP/IP socket with <code>socket.socket()</code></li>
<li>bind the socket to an address and a port with <code>sock.bind()</code></li>
<li>mark the socket as a "listening" socket with <code>sock.listen()</code></li>
<li>accept new connections with <code>sock.accept()</code></li>
<li>read data from the client with <code>sock.recv()</code> and send the data back to the client with <code>sock.sendall()</code>.</li>
</ol><p></p><p>This version of server is not concurrent by design. When multiple clients try to connect to the server at about the same time, one client connects and occupies the server, while other clients wait until the current client disconnects. I wrote a <a href="https://github.com/r4victor/pbts12_async_await/blob/master/clients.py">simple simulation program</a> to demonstrate this:</p><p></p><div><pre>$ python clients.py 
[00.097034] Client 0 tries to connect.
        [00.097670] Client 1 tries to connect.
                [00.098334] Client 2 tries to connect.
[00.099675] Client 0 connects.
[00.600378] Client 0 sends "Hello".
[00.601602] Client 0 receives "Hello".
[01.104952] Client 0 sends "world!".
[01.105166] Client 0 receives "world!".
[01.105276] Client 0 disconnects.
        [01.106323] Client 1 connects.
        [01.611248] Client 1 sends "Hello".
        [01.611609] Client 1 receives "Hello".
        [02.112496] Client 1 sends "world!".
        [02.112691] Client 1 receives "world!".
        [02.112772] Client 1 disconnects.
                [02.113569] Client 2 connects.
                [02.617032] Client 2 sends "Hello".
                [02.617288] Client 2 receives "Hello".
                [03.120725] Client 2 sends "world!".
                [03.120944] Client 2 receives "world!".
                [03.121044] Client 2 disconnects.

</pre></div><p></p><p>The clients connect, send the same two messages and disconnect. It takes half a second for a client to type a message, and thus it takes about three seconds for the server to serve all the clients. A single slow client, however, could make the server unavailable for an arbitrary long time. We should really make the server concurrent!</p><p></p><h2 id="sr-toc-2">OS threads</h2><p></p><p>The easiest way to make the server concurrent is by using OS threads. We just run the <code>handle_client()</code> function in a separate thread instead of calling it in the main thread and leave the rest of the code  unchanged:</p><p></p><div><pre># echo_02_threads.py

import socket
import threading


def run_server(host='127.0.0.1', port=55555):
    sock = socket.socket()
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, port))
    sock.listen()
    while True:
        client_sock, addr = sock.accept()
        print('Connection from', addr)
        thread = threading.Thread(target=handle_client, args=[client_sock])
        thread.start()


def handle_client(sock):
    while True:
        received_data = sock.recv(4096)
        if not received_data:
            break
        sock.sendall(received_data)

    print('Client disconnected:', sock.getpeername())
    sock.close()


if __name__ == '__main__':
    run_server()

</pre></div><p></p><p>Now multiple clients can talk to the server simultaneously:</p><p></p><div><pre>$ python clients.py 
[00.095948] Client 0 tries to connect.
        [00.096472] Client 1 tries to connect.
                [00.097019] Client 2 tries to connect.
[00.099666] Client 0 connects.
        [00.099768] Client 1 connects.
                [00.100916] Client 2 connects.
[00.602212] Client 0 sends "Hello".
        [00.602379] Client 1 sends "Hello".
                [00.602506] Client 2 sends "Hello".
[00.602702] Client 0 receives "Hello".
        [00.602779] Client 1 receives "Hello".
                [00.602896] Client 2 receives "Hello".
[01.106935] Client 0 sends "world!".
        [01.107088] Client 1 sends "world!".
                [01.107188] Client 2 sends "world!".
[01.107342] Client 0 receives "world!".
[01.107814] Client 0 disconnects.
        [01.108217] Client 1 receives "world!".
        [01.108305] Client 1 disconnects.
                [01.108345] Client 2 receives "world!".
                [01.108395] Client 2 disconnects.

</pre></div><p></p><p>The one-thread-per-client approach is easy to implement, but it doesn't scale well. OS threads are an expensive resource in terms of memory, so you can't have too many of them. For example, the Linux machine that serves this website is capable of running about 8k threads at most, though even fewer threads may be enough to swamp it. With this approach the server not only works poorly under heavy workloads but also becomes an easy target for a DoS attack.</p><p></p><p>Thread pools solve the problem of uncontrolled thread creation. Instead of submitting each task to a separate thread, we submit tasks to a queue and let a group of threads, called a <strong>thread pool</strong>, take and process the tasks  from the queue. We predefine the maximum number of threads in a thread pool, so the server cannot start too many of them. Here's how we can write a thread pool version of the server using the Python standard <a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor"><code>concurrent.futures</code></a> module:</p><p></p><div><pre># echo_03_thread_pool.py

import socket
from concurrent.futures import ThreadPoolExecutor


pool = ThreadPoolExecutor(max_workers=20)


def run_server(host='127.0.0.1', port=55555):
    sock = socket.socket()
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, port))
    sock.listen()
    while True:
        client_sock, addr = sock.accept()
        print('Connection from', addr)
        pool.submit(handle_client, client_sock)


def handle_client(sock):
    while True:
        received_data = sock.recv(4096)
        if not received_data:
            break
        sock.sendall(received_data)

    print('Client disconnected:', sock.getpeername())
    sock.close()


if __name__ == '__main__':
    run_server()

</pre></div><p></p><p>The thread pool approach is both simple and practical. Note, however, that you still need to do something to prevent slow clients from occupying the thread pool. You may drop long-living connections, require the clients to maintain some minimum throughput rate, let the threads return the tasks to the queue or combine any of the suggested methods. The conclusion here is that making the server concurrent using OS threads is not as straightforward as it may seem at first, and it's worthwhile to explore other approaches to concurrency. </p><p></p><h2 id="sr-toc-3">I/O multiplexing and event loops</h2><p></p><p>Think about the sequential server again. Such a server always waits for some specific event to happen. When it has no connected clients, it waits for a new client to connect. When it has a connected client, it waits for this client to send some data. To work concurrently, however, the server should instead be able to handle any event that happens next. If the current client doesn't send anything, but a new client tries to connect, the server should accept the new connection. It should maintain multiple active connections and reply to any client that sends data next.</p><p></p><p>But how can the server know what event it should handle next? By default, socket methods such as <code>accept()</code>, <code>recv()</code> and <code>sendall()</code> are all blocking. So if the server decides to call <code>accept()</code>, it will block until a new client connects and won't be not able to call <code>recv()</code> on the client sockets in the meantime. We could solve this problem by setting a timeout on blocking socket operations with <code>sock.settimeout(timeout)</code> or by turning a socket into a completely non-blocking mode with <code>sock.setblocking(False)</code>. We could then maintain a set of active sockets and, for each socket, call the corresponding socket method in an infinite loop. So, we would call <code>accept()</code> on the socket that listens for new connections and <code>recv()</code> on the sockets that wait for clients to send data.</p><p></p><p>The problem with the described approach is that it's not clear how to do the polling right. If we make all the sockets non-blocking or set timeouts too short, the server will be making calls all the time and consume a lot of CPU. Conversely, if we set timeouts too long, the server will be slow to reply.</p><p></p><p>The better approach is to ask the OS which sockets are ready for reading and writing. Clearly, the OS has this information. When a new packet arrives on a network interface, the OS gets notified, decodes the packet, determines the socket to which the packet belongs and wakes up the processes that do a blocking read on that socket. But a process doesn't need to read from the socket to get notified. It can use an <strong>I/O multiplexing</strong> mechanism such as <a href="https://man7.org/linux/man-pages/man2/select.2.html"><code>select()</code></a>, <a href="https://man7.org/linux/man-pages/man2/poll.2.html"><code>poll()</code></a> or <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code>epoll()</code></a> to tell the OS that it's interested in reading from or writing to some socket. When the socket becomes ready, the OS will wake up such processes as well.</p><p></p><p>The Python standard <a href="https://docs.python.org/3/library/selectors.html"><code>selectors</code></a> module wraps different I/O multiplexing mechanisms available on the system and exposes each of them via the same high-level API called a <strong>selector</strong>. So it exposes <code>select()</code> as <code>SelectSelector</code> and <code>epoll()</code> as <code>EpollSelector</code>. It also exposes the most efficient mechanism available on the system as <code>DefaultSelector</code>.</p><p></p><p>Let me show you how you're supposed to use the <code>selectors</code> module. You first create a selector object:</p><p></p><div><pre>sel = selectors.DefaultSelector()

</pre></div><p></p><p>Then you register a socket that you want to monitor. You pass the socket, the types of events you're interested in (the socket becomes ready for reading or writing) and any auxiliary data to the selector's <a href="https://docs.python.org/3/library/selectors.html#selectors.BaseSelector.register"><code>register()</code></a> method:</p><p></p><div><pre>sel.register(sock, selectors.EVENT_READ, my_data)

</pre></div><p></p><p>Finally, you call the selector's <a href="https://docs.python.org/3/library/selectors.html#selectors.BaseSelector.select"><code>select()</code></a> method:</p><p></p><div><pre>keys_events = sel.select()

</pre></div><p></p><p>This call returns a list of <code>(key, events)</code> tuples. Each tuple describes a ready socket:</p><p></p><ul>
<li><code>key</code> is an object that stores the socket (<code>key.fileobj</code>) and the auxiliary data associated with the socket (<code>key.data</code>).</li>
<li><code>events</code> is a bitmask of events ready on the socket (<code>selectors.EVENT_READ</code> or <code>selectors.EVENT_WRITE</code> or both).</li>
</ul><p></p><p>If there are ready sockets when you call <code>select()</code>, then <code>select()</code> returns immediately. Otherwise, it blocks until some of the registered sockets become ready. The OS will notify <code>select()</code> as it notifies blocking socket methods like <code>recv()</code>.</p><p></p><p>When you no longer need to monitor some socket, you just pass it to the selector's <a href="https://docs.python.org/3/library/selectors.html#selectors.BaseSelector.unregister"><code>unregister()</code></a> method.</p><p></p><p>One question remains. What should we do with a ready socket? We certainly had some idea of what do to with it when we registered it, so let's register every socket with a callback that should be called when the socket becomes ready. That's, by the way, what the auxiliary data parameter of the selector's <code>register()</code> method is for. </p><p></p><p>We're now ready to implement a single-threaded concurrent version of the server using I/O multiplexing:</p><p></p><div><pre># echo_04_io_multiplexing.py

import socket
import selectors


sel = selectors.DefaultSelector()


def setup_listening_socket(host='127.0.0.1', port=55555):
    sock = socket.socket()
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, port))
    sock.listen()
    sel.register(sock, selectors.EVENT_READ, accept)


def accept(sock):
    client_sock, addr = sock.accept()
    print('Connection from', addr)
    sel.register(client_sock, selectors.EVENT_READ, recv_and_send)


def recv_and_send(sock):
    received_data = sock.recv(4096)
    if received_data:
        # assume sendall won't block
        sock.sendall(received_data)
    else:
        print('Client disconnected:', sock.getpeername())
        sel.unregister(sock)
        sock.close()


def run_event_loop():
    while True:
        for key, _ in sel.select():
            callback = key.data
            sock = key.fileobj
            callback(sock)


if __name__ == '__main__':
    setup_listening_socket()
    run_event_loop()

</pre></div><p></p><p>Here we first register an <code>accept()</code> callback on the listening socket. This callback accepts new clients and registers a <code>recv_and_send()</code> callback on every client socket. The core of the program is the <strong>event loop</strong> –&nbsp;an infinite loop that on each iteration selects ready sockets and calls the corresponding registered callbacks.</p><p></p><p>The event loop version of the server handles multiple clients perfectly fine. Its main disadvantage compared to the multi-threaded versions is that the code is structured in a weird, callback-centered way. The code in our example doesn't look so bad, but this is in part because we do not handle all the things properly. For example, writing to a socket may block if the write queue is full, so we should also check whether the socket is ready for writing before calling <code>sock.sendall()</code>. This means that the <code>recv_and_send()</code> function must be decomposed into two functions, and one of these functions must be registered as a callback at any given time depending on the server's state. The problem would be even more apparent if implemented something more complex than the primitive echo protocol.</p><p></p><p>OS threads do not impose callback style programming on us, yet they provide concurrency. How do they do that? The key here is the ability of the OS to suspend and resume thread execution. If we had functions that can be suspended and resumed like OS threads, we could write concurrent single-threaded code. Guess what? Pyhon allows us to write such functions. </p><p></p><h2 id="sr-toc-4">Generator functions and generators</h2><p></p><p>A <strong>generator function</strong> is a function that has one or more <a href="https://docs.python.org/3/reference/expressions.html#yield-expressions"><code>yield</code></a> expressions in its body, like this one:</p><p></p><div><pre>$ python -q
&gt;&gt;&gt; def gen():
...     yield 1
...     yield 2
...     return 3
... 
&gt;&gt;&gt; 

</pre></div><p></p><p>When you call a generator function, Python doesn't run the function's code as it does for ordinary functions but returns a <strong>generator object</strong>, or simply a <strong>generator</strong>:</p><p></p><div><pre>&gt;&gt;&gt; g = gen()
&gt;&gt;&gt; g
&lt;generator object gen at 0x105655660&gt;

</pre></div><p></p><p>To actually run the code, you pass the generator to the built-in <a href="https://docs.python.org/3/library/functions.html#next"><code>next()</code></a> function. This function calls the generator's <a href="https://docs.python.org/3/reference/expressions.html#generator.__next__"><code>__next__()</code></a> method that runs the generator to the first <code>yield</code> expression, at which point it suspends the execution and returns the argument of <code>yield</code>. Calling <code>next()</code> second time resumes the generator from the point where it was suspended, runs it to the next <code>yield</code> expression and returns its argument:</p><p></p><div><pre>&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
2

</pre></div><p></p><p>When no more <code>yield</code> expressions are left, calling <code>next()</code> raises a <code>StopIteration</code> exception:</p><p></p><div><pre>&gt;&gt;&gt; next(g)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration: 3

</pre></div><p></p><p>If the generator returns something, the exception holds the returned value:</p><p></p><div><pre>&gt;&gt;&gt; g = gen()
&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
2
&gt;&gt;&gt; try:
...     next(g)
... except StopIteration as e:
...     e.value
... 
3

</pre></div><p></p><p>Initially generators were introduced to Python as an alternative way to write iterators. Recall that in Python an object that can be iterated over (as with a <code>for</code> loop) is called an <strong>iterable</strong>. An iterable implements the <a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__"><code>__iter__()</code></a> special method that returns an <strong>iterator</strong>. An iterator, in turn, implements <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__"><code>__next__()</code></a> that returns the next value every time you call it. You can get the values by calling <code>next()</code>, but you typically iterate over them with a <code>for</code> loop:</p><p></p><div><pre>&gt;&gt;&gt; for i in gen():
...     i
... 
1
2

</pre></div><p></p><p>Iterators can be iterated over because they are iterables too. Every iterator implements <a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__"><code>__iter__()</code></a> that returns the iterator itself.</p><p></p><p>Generators allowed us to write iterators as functions that <code>yield</code> values instead of defining classes with special methods. Python fills the special methods for us so that generators become iterators automatically.</p><p></p><p>Generators produce values in a lazy, on-demand manner, so they are memory-efficient and can even be used to generate infinite sequences. See <a href="https://www.python.org/dev/peps/pep-0255/">PEP 255</a> to learn more about such uses cases. We want to use generators for a completely different reason, though. What's important for us is not the values that a generator produces but the fact that it can be suspended and resumed.</p><p></p><h2 id="sr-toc-5">Generators as coroutines</h2><p></p><p>Take any program that performs multiple tasks. Turn functions that represent these tasks into generators by inserting few <code>yield</code> statements here and there. Then run the generators in a round-robin fashion: call <code>next()</code> on every generator in some fixed order and repeat this step until all the generators are exhausted. You'll get a concurrent program that runs like this:</p><p></p><p><div class="sr-rd-content-center"><img class="sr-rd-content-img" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABicAAADXCAYAAABxhIJvAAAAAXNSR0IArs4c6QAACFJ0RVh0bXhmaWxlACUzQ214ZmlsZSUyMGhvc3QlM0QlMjJhcHAuZGlhZ3JhbXMubmV0JTIyJTIwbW9kaWZpZWQlM0QlMjIyMDIxLTA4LTIxVDEwJTNBNTQlM0E1Ny44OTJaJTIyJTIwYWdlbnQlM0QlMjI1LjAlMjAoTWFjaW50b3NoJTNCJTIwSW50ZWwlMjBNYWMlMjBPUyUyMFglMjAxMF8xNF82KSUyMEFwcGxlV2ViS2l0JTJGNTM3LjM2JTIwKEtIVE1MJTJDJTIwbGlrZSUyMEdlY2tvKSUyMENocm9tZSUyRjkyLjAuNDUxNS4xMzElMjBTYWZhcmklMkY1MzcuMzYlMjIlMjBldGFnJTNEJTIyUFZiUzJkaUhaUmJpYmt0bHVqMmglMjIlMjB2ZXJzaW9uJTNEJTIyMTQuNS4xJTIyJTNFJTNDZGlhZ3JhbSUyMGlkJTNEJTIyQWh1ZTRsbjJvelZCN1dvNGFVQzYlMjIlMjBuYW1lJTNEJTIyUGFnZS0xJTIyJTNFNVZ0Yms2STRGUDQxJTJGVGhVN3BmSGJuZG1kbmQycTZhcUgzWmZhWWxJRFlLTHNiWDMxMiUyQlFBQ0tvMkNzU3AzMkljSUFrbnZOOTU1TGdBNTRzdGw4emZ6biUyRk13MVUlMkZJQkFzSDNBdnp3Z2hCZ0M1aXVYdkJVU2lDUXVKR0VXQlZaV0M1NmpmNVVWMmdmRGRSU29WZU5HbmFheGpwWk40VFJORWpYVkRabWZaZW1tZWRzc2padWpMdjFRdFFUUFV6OXVTJTJGJTJCS0FqMjNVZ1pBZmVGWEZZWHpjbWhVWGxuNDVkMVdzSnI3UWJyWkUlMkJIUEQzaVNwYWt1amhiYmlZcHo5WldLS1o3N2N1UnFOYk5NSmJyUEE2RVFyNU8lMkYwUmZKdmkxJTJGZTlWJTJGZlB2eCUyQiUyRmRQdHBkWFAxN2JYMnducTk5S0ZhZ2tlTXcxYWM2U05ESENwN2xleE9ZTW1zT1Z6dElmbFdxNGtSVFBxNkNsMTNxZVZyUksxOWxVblpvY3JkUmtFS2JTaGRMWm0zbHcyOFNJeFJZaTlueFRHNHBhMFh6UFJLWE10OUFJcTQ2cnNiNm5rWmxyUFJEQm5vUkNBRXlLdGprdXh4N2hVZ2dLS0NjYzRtYjN4YSUyQjBQZTZiNTNBUXlwa25pS3clMkIlMkZKSlJ0SiUyQkZTcmRHTVFkN21xdEZPMmhjQUJOMEhpWlp1azRDbFhjQ0RBbzI4MGlyNTZXJTJGcyUyQiUyRkdPSWNtYkdaUkhFJTJGU09NMTJ6JTJCTEFWMkkycmVDMGQ0Vk5oWHFaVmJCNlZabFcyOVBBT29vWEpBOEJ3enplZ2d3RXdxT2tBemJZbyUyRnc0Y2hvYXYxUzlkRVFXRnNnNVolMkZ2eFNZall3VWo4M1VTVHdFT2s1ak55aUdqc1p5QWFvOUtUa2hGSk9kcTFMZG94U1NYbkFFSWlDYUl0eEVqc2NZSWhRMWp1V3RGTlI4YUZpY1FTU2twS0kxNmRtdHpsQUlsNlVwaTVRV0ZDb1NjeEFoUWlzV3ZwaHd1azBtVTRRVVRjQU1ycGhBdlQzSUtVUW02OE9PYnklMkZUaHBJZ09UZyUyRmclMkJNQlpLZFE3bTdLa1NBZWx5OWdLOVlNYXU0JTJCeXhyUE9sVXBGUUdnJTJGZndnWUUwQ09zMjVVUGxWbkJNUXVjczM0WmdwT3FIUzIzd3FXWnJweGJtWDVQTVhkb3ZnMWR4ZHlFYjl6UWhXUEpxSUF3Ynp1WVZ5ZEZ1QVVZaDFLck12UTZHZ3hCWHhJN1VpQ2R5YTdPY085SzJkWElETzlSU0x0ZlBnbTVLNSUyQnF6OFhsRXhUY0k0SmhSSGpSSGdtNk55RjVqNHAyUEpLenZoeDNaQ1dTRyUyRiUyRk8yUkhuJTJGeEhxSiUyQmgyUFk3ZGdNbnAlMkJva2drNGNMNnp5UTRQamR5ZDVKb0p3Ylp1Z2w2NEdycTlsTXNXbG5MQWk0ZkFIZ09yR0Fnb1BNUE0lMkZmMmc2ZmRjRm13TElLT1YxV0lVZkxLb0lPdXJnYTA4Q29UQnR6JTJCNkxIb3BZanE1OFFVR0p5cnIzUFJVYnNqUlhUa3djb2toS1NYWHQ2R0hKYnFIUmxneXpXT1FpV2Z0TEFEUHRublclMkJOUDgzU1JIOWE3ZDRNZURRM0VMamMxaGZOVVpoJTJGaHlwUm1hJTJCTkMwWUFsbDJhS1JhOUZ2ZTBRR25jc3U1Q1l1bkxMVkwzSGI4ViUyQlhFVUp1WjBh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" sr-org-src="https://tenthousandmeters.com/blog/python_bts_12/generators.png"></div></p><p></p><p>Let's apply this strategy to the sequential server to make it concurrent. First we need to insert some <code>yield</code> statements. I suggest to insert them before every blocking operation. Then we need to run generators. I suggest to write a class that does this. The class should provide the <code>create_task()</code> method that adds a generator to a queue of scheduled generators (or simply tasks) and the <code>run()</code> method that runs the tasks in a loop in a round-robin fashion. We'll call this class <code>EventLoopNoIO</code> since it functions like an event loop except that it doesn't do I/O multiplexing. Here's the server code:</p><p></p><div><pre># echo_05_yield_no_io.py

import socket

from event_loop_01_no_io import EventLoopNoIO


loop = EventLoopNoIO()


def run_server(host='127.0.0.1', port=55555):
    sock = socket.socket()
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, port))
    sock.listen()
    while True:
        yield
        client_sock, addr = sock.accept()
        print('Connection from', addr)
        loop.create_task(handle_client(client_sock))


def handle_client(sock):
    while True:
        yield
        received_data = sock.recv(4096)
        if not received_data:
            break
        yield
        sock.sendall(received_data)

    print('Client disconnected:', sock.getpeername())
    sock.close()


if __name__ == '__main__':
    loop.create_task(run_server())
    loop.run()

</pre></div><p></p><p>And here's the event loop code:</p><p></p><div><pre># event_loop_01_no_io.py

from collections import deque


class EventLoopNoIO:
    def __init__(self):
        self.tasks_to_run = deque([])

    def create_task(self, coro):
        self.tasks_to_run.append(coro)

    def run(self):
        while self.tasks_to_run:
            task = self.tasks_to_run.popleft()
            try:
                next(task)
            except StopIteration:
                continue
            self.create_task(task)

</pre></div><p></p><p>This counts as a concurrent server. You may notice, however, that it has a problem.  Its concurrency is very limited. The tasks run in an interleaved manner, but their order is fixed. For example, if the currently scheduled task is the task that accepts new connections, tasks that handle connected clients have to wait until a new client connects.</p><p></p><p>Another way to phrase this problem is to say that the event loop doesn't check whether socket operations will block. As we've learned, we can fix it by adding I/O multiplexing. Instead of rescheduling a task immediately after running it, the event loop should reschedule the task only when the socket that the task is waiting on becomes available for reading (or writing). A task can register its intention to read from or write to a socket by calling some event loop method. Or it can just <code>yield</code> this information to the event loop. Here's a version of the server that takes the latter approach:</p><p></p><div><pre># echo_06_yield_io.py

import socket

from event_loop_02_io import EventLoopIo


loop = EventLoopIo()


def run_server(host='127.0.0.1', port=55555):
    sock = socket.socket()
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, port))
    sock.listen()
    while True:
        yield 'wait_read', sock
        client_sock, addr = sock.accept()
        print('Connection from', addr)
        loop.create_task(handle_client(client_sock))


def handle_client(sock):
    while True:
        yield 'wait_read', sock
        received_data = sock.recv(4096)
        if not received_data:
            break
        yield 'wait_write', sock
        sock.sendall(received_data)

    print('Client disconnected:', sock.getpeername())
    sock.close()


if __name__ == '__main__':
    loop.create_task(run_server())
    loop.run()

</pre></div><p></p><p>And here's the new event loop that does I/O multiplexing:</p><p></p><div><pre># event_loop_02_io.py

from collections import deque
import selectors


class EventLoopIo:
    def __init__(self):
        self.tasks_to_run = deque([])
        self.sel = selectors.DefaultSelector()

    def create_task(self, coro):
        self.tasks_to_run.append(coro)

    def run(self):
        while True:
            if self.tasks_to_run:
                task = self.tasks_to_run.popleft()
                try:
                    op, arg = next(task)
                except StopIteration:
                    continue

                if op == 'wait_read':
                    self.sel.register(arg, selectors.EVENT_READ, task)
                elif op == 'wait_write':
                    self.sel.register(arg, selectors.EVENT_WRITE, task)
                else:
                    raise ValueError('Unknown event loop operation:', op)
            else:
                for key, _ in self.sel.select():
                    task = key.data
                    sock = key.fileobj
                    self.sel.unregister(sock)
                    self.create_task(task)

</pre></div><p></p><p>What do we get out of it? First, we get the server that handles multiple clients perfectly fine:</p><p></p><div><pre>$ python clients.py 
[00.160966] Client 0 tries to connect.
        [00.161494] Client 1 tries to connect.
                [00.161783] Client 2 tries to connect.
[00.163256] Client 0 connects.
        [00.163409] Client 1 connects.
                [00.163470] Client 2 connects.
[00.667343] Client 0 sends "Hello".
        [00.667491] Client 1 sends "Hello".
                [00.667609] Client 2 sends "Hello".
[00.667886] Client 0 receives "Hello".
        [00.668160] Client 1 receives "Hello".
                [00.668237] Client 2 receives "Hello".
[01.171159] Client 0 sends "world!".
        [01.171320] Client 1 sends "world!".
                [01.171439] Client 2 sends "world!".
[01.171610] Client 0 receives "world!".
[01.171839] Client 0 disconnects.
        [01.172084] Client 1 receives "world!".
        [01.172154] Client 1 disconnects.
                [01.172190] Client 2 receives "world!".
                [01.172237] Client 2 disconnects.

</pre></div><p></p><p>Second, we get the code that looks like regular sequential code. Of course, we had to write the event loop, but this is not something you typically do yourself. Event loops come with libraries, and in Python you're most likely to use an event loop that comes with <a href="https://docs.python.org/3/library/asyncio.html"><code>asyncio</code></a>.</p><p></p><p>When you use generators for multitasking, as we did in this section, you typically refer to them as coroutines. <strong>Coroutines</strong> are functions that can be suspended by explicitly yielding the control. So, according to this definition, simple generators with <code>yield</code> expressions can be counted as coroutines. A true coroutine, however, should also be able to yield the control to other coroutines by calling them, but generators can yield the control only to the caller.</p><p></p><p>We'll see why we need true coroutines if try to factor out some generator's code into a subgenerator. Consider these two lines of code of the <code>handle_client()</code> generator:</p><p></p><div><pre>yield 'wait_read', sock
received_data = sock.recv(4096)

</pre></div><p></p><p>It would be very handy to factor them out into a separate function:</p><p></p><div><pre>def async_recv(sock, n):
    yield 'wait_read', sock
    return sock.recv(n)

</pre></div><p></p><p>and then call the function like this:</p><p></p><div><pre>received_data = async_recv(sock, 4096)

</pre></div><p></p><p>But it won't work. The <code>async_recv()</code> function returns a generator, not the data. So the <code>handle_client()</code> generator has to run the <code>async_recv()</code> subgenerator with <code>next()</code>. However, it can't just keep calling <code>next()</code> until the subgenerator is exhausted. The subgenerator yields values to the event loop, so <code>handle_client()</code> has to reyield them. It also has to handle the <code>StopIteration</code> exception and extract the result. Obviously, the amount of work that it has to do exceeds all the benefits of factoring out two lines of code.</p><p></p><p>Python made several attempts at solving this issue. First, <a href="https://www.python.org/dev/peps/pep-0342/">PEP 342</a> introduced enhanced generators in Python 2.5. Generators got the <a href="https://docs.python.org/3/reference/expressions.html#generator.send"><code>send()</code></a> method that works like <code>__next__()</code> but also sends a value to the generator. The value becomes the value of the <code>yield</code> expression that the generator is suspended on:</p><p></p><div><pre>&gt;&gt;&gt; def consumer():
...     val = yield 1
...     print('Got', val)
...     val = yield
...     print('Got', val)
... 
&gt;&gt;&gt; c = consumer()
&gt;&gt;&gt; next(c)
1
&gt;&gt;&gt; c.send(2)
Got 2
&gt;&gt;&gt; c.send(3)
Got 3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration

</pre></div><p></p><p>The generators' <code>__next__()</code> method became simply a shorthand for <code>send(None)</code>.</p><p></p><p>Generators also got the <a href="https://docs.python.org/3/reference/expressions.html#generator.throw"><code>throw()</code></a> method that runs the generator like <code>send()</code> or <code>__next__()</code> but also raises a specified exception at the suspension point and the <a href="https://docs.python.org/3/reference/expressions.html#generator.close"><code>close()</code></a> method that raises a <a href="https://docs.python.org/3/library/exceptions.html#GeneratorExit"><code>GeneratorExit</code></a> exception.</p><p></p><p>Here's how this enhancement solved the subgenerator issue. Instead of running a subgenerator in place, a generator could now <code>yield</code> it to the event loop, and the event loop would run the subgenerator and then <code>send()</code> the result back to the generator (or throw an exception into the generator if the subgenerator raised one). The generator would call the subgenerator like this:</p><p></p><div><pre>received_data = yield async_recv(sock)

</pre></div><p></p><p>And this call would work just as if one coroutine calls another.</p><p></p><p>This solution requires some non-trivial logic in the event loop, and you may find it hard to understand. Don't worry. You don't have to. <a href="https://www.python.org/dev/peps/pep-0380/">PEP 380</a> introduced a much more intuitive solution for implementing coroutines in Python 3.3.</p><p></p><h2 id="sr-toc-6">yield from</h2><p></p><p>You've probably used <code>yield from</code> to yield values from an iterable. So you should know that this statement:</p><p></p><p>works as a shorthand for this piece of code:</p><p></p><div><pre>for i in iterable:
    yield i

</pre></div><p></p><p>But <code>yield from</code> does much more when you use it with generators. It does exactly what a generator has to do to run a subgenerator in place, and that's why we're discussing it. The main steps of <code>yield from</code> are:</p><p></p><ol>
<li>Run the subgenerator once with <code>send(None)</code>. If <code>send()</code> raises a <code>StopIteration</code> exception, catch the exception, extract the result, make it a value of the <code>yield from</code> expression and stop.</li>
<li>If subgenerator's <code>send()</code> returns a value without exceptions, <code>yield</code> the value and receive a value sent to the generator.</li>
<li>When received a value, repeat step 1 but this time <code>send()</code> the received value.</li>
</ol><p></p><p>This algorithm requires some elaboration. First, <code>yield from</code> automatically propagates exceptions thrown by calling the generator's <code>throw()</code> and <code>close()</code> methods into the subgenerator. The implementation of these methods ensures this. Second, <code>yield from</code> applies the same algorithm to non-generator iterables except that it gets an iterator with <code>iter(iterable)</code> and then uses <code>__next__()</code> instead <code>send()</code> to run the iterator.</p><p></p><p>Here's how you can remember what <code>yield from</code> does: it makes the subgenerator work as if the subgenerator's code were a part of the generator. So this <code>yield from</code> call:</p><p></p><div><pre>received_data = yield from async_recv(sock)

</pre></div><p></p><p>works as if the call were replaced with the code of <code>async_recv()</code>. This also counts as a coroutine call, and in contrast to the previous <code>yield</code>-based solution, the event loop logic stays the same.</p><p></p><p>Let's now take advantage of <code>yield from</code> to make the server's code more concise. First we factor out every boilerplate <code>yield</code> statement and the following socket operation to a separate generator function. We put these functions in the event loop:</p><p></p><div><pre># event_loop_03_yield_from.py

from collections import deque
import selectors


class EventLoopYieldFrom:
    def __init__(self):
        self.tasks_to_run = deque([])
        self.sel = selectors.DefaultSelector()

    def create_task(self, coro):
        self.tasks_to_run.append(coro)

    def sock_recv(self, sock, n):
        yield 'wait_read', sock
        return sock.recv(n)

    def sock_sendall(self, sock, data):
        yield 'wait_write', sock
        sock.sendall(data)

    def sock_accept(self, sock):
        yield 'wait_read', sock
        return sock.accept()

    def run(self):
        while True:
            if self.tasks_to_run:
                task = self.tasks_to_run.popleft()
                try:
                    op, arg = next(task)
                except StopIteration:
                    continue

                if op == 'wait_read':
                    self.sel.register(arg, selectors.EVENT_READ, task)
                elif op == 'wait_write':
                    self.sel.register(arg, selectors.EVENT_WRITE, task)
                else:
                    raise ValueError('Unknown event loop operation:', op)
            else:
                for key, _ in self.sel.select():
                    task = key.data
                    sock = key.fileobj
                    self.sel.unregister(sock)
                    self.create_task(task)

</pre></div><p></p><p>Then we <code>yield from</code> the generators in the server's code:</p><p></p><div><pre># echo_07_yield_from.py

import socket

from event_loop_03_yield_from import EventLoopYieldFrom


loop = EventLoopYieldFrom()


def run_server(host='127.0.0.1', port=55555):
    sock = socket.socket()
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, port))
    sock.listen()
    while True:
        client_sock, addr = yield from loop.sock_accept(sock)
        print('Connection from', addr)
        loop.create_task(handle_client(client_sock))


def handle_client(sock):
    while True:
        received_data = yield from loop.sock_recv(sock, 4096)
        if not received_data:
            break
        yield from loop.sock_sendall(sock, received_data)

    print('Client disconnected:', sock.getpeername())
    sock.close()


if __name__ == '__main__':
    loop.create_task(run_server())
    loop.run()

</pre></div><p></p><p>And that's it! Generators, <code>yield</code> and <code>yield from</code> are all we need to implement coroutines, and coroutines allow us to write asynchronous, concurrent code that looks like regular sequential code. What about <code>async</code>/<code>await</code>? Well, it's just a syntactic feature on top of generators that was introduced to Python to fix the generators' ambiguity.</p><p></p><h2 id="sr-toc-7">async/await</h2><p></p><p>When you see a generator function, you cannot always say immediately whether it's intended to be used as a regular generator or as a coroutine. In both cases, the function looks like any other function defined with <code>def</code> and contains a bunch of <code>yield</code> and <code>yield from</code> expressions. So to make coroutines a distinct concept, <a href="https://www.python.org/dev/peps/pep-0492/">PEP 492</a> introduced the <code>async</code> and <code>await</code> keywords in Python 3.5.</p><p></p><p>You define a <strong>native coroutine</strong> <strong>function</strong> using the <code>async def</code> syntax:</p><p></p><div><pre>&gt;&gt;&gt; async def coro():
...     return 1
... 

</pre></div><p></p><p>When you call such a function, it returns a <strong>native coroutine object</strong>, or simply a <strong>native coroutine</strong>. A native coroutine is pretty much the same thing as a generator except that it has a different type and doesn't implement <code>__next__()</code>. Event loops call <code>send(None)</code> to run native coroutines:</p><p></p><div><pre>&gt;&gt;&gt; coro().send(None)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration: 1

</pre></div><p></p><p>Native coroutines can call each other with the <code>await</code> keyword:</p><p></p><div><pre>&gt;&gt;&gt; async def coro2():
...     r = await coro()
...     return 1 + r
... 
&gt;&gt;&gt; coro2().send(None)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration: 2

</pre></div><p></p><p>The <code>await</code> keyword does exactly what <code>yield from</code> does but for native coroutines. In fact, <code>await</code> is implemented as <code>yield from</code> with some additional checks to ensure that the object being awaited is not a generator or some other iterable.</p><p></p><p>When you use generators as coroutines, you must end every chain of <code>yield from</code> calls with a generator that does <code>yield</code>. Similarly, you must end every chain of <code>await</code> calls with a <code>yield</code> expression. However, if you try to use a <code>yield</code> expression in an <code>async def</code> function, what you'll get is not a native coroutine but something called an asynchronous generator:</p><p></p><div><pre>&gt;&gt;&gt; async def g():
...     yield 2
... 
&gt;&gt;&gt; g()
&lt;async_generator object g at 0x1046c6790&gt;

</pre></div><p></p><p>We're not going spend time on asynchronous generators here, but in a nutshell, they implement the asynchronous version of the iterator protocol: the <a href="https://docs.python.org/3/reference/datamodel.html#object.__aiter__"><code>__aiter__()</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__anext__"><code>__anext__()</code></a> special methods (see <a href="https://www.python.org/dev/peps/pep-0525/">PEP 525 </a> to learn more). What's important for us at now is that <code>__anext__()</code> is awaitable, while asynchronous generators themeselves are not. Thus, we cannot end a chain of <code>await</code> calls with an <code>async def</code> function containing <code>yield</code>. What should we end the chain with? There are two options.</p><p></p><p>First, we can write a regular generator function and decorate it with <code>@types.coroutine</code>. This decorator sets a special flag on the function behind the generator so that the generator can be used in an <code>await</code> expression just like a native coroutine:</p><p></p><div><pre>&gt;&gt;&gt; import types
&gt;&gt;&gt; @types.coroutine
... def gen_coro():
...     yield 3
... 
&gt;&gt;&gt; async def coro3():
...     await gen_coro()
... 
&gt;&gt;&gt; coro3().send(None)
3

</pre></div><p></p><p>A generator decorated with <code>@types.coroutine</code> is called a <strong>generator-based coroutine</strong>. Why do we need such coroutines? Well, if Python allowed us to <code>await</code> on regular generators, we would again mix the concepts of generators and coroutines and come back to the same ambiguity problem. The <code>@types.coroutine</code> decorator explicitly says that the generator is a coroutine.</p><p></p><p>As a second option, we can make any object awaitable by defining the <a href="https://docs.python.org/3/reference/datamodel.html#object.__await__"><code>__await__()</code></a> special method. When we <code>await</code> on some object, <code>await</code> first checks whether the object is a native coroutine or a generator-based coroutine, in which case it "yields from" the coroutine. Otherwise, it "yields from" the iterator returned by the object's <code>__await__()</code> method. Since any generator is an iterator, <code>__await__()</code> can be a regular generator function:</p><p></p><div><pre>&gt;&gt;&gt; class A:
...     def __await__(self):
...             yield 4
... 
&gt;&gt;&gt; async def coro4():
...     await A()
... 
&gt;&gt;&gt; coro4().send(None)
4

</pre></div><p></p><p>Let's now write the final version of the server using <code>async</code>/<code>await</code>. First we mark the server's functions as <code>async</code> and change <code>yield from</code> calls to <code>await</code> calls:</p><p></p><div><pre># echo_08_async_await.py

import socket

from event_loop_04_async_await import EventLoopAsyncAwait


loop = EventLoopAsyncAwait()


async def run_server(host='127.0.0.1', port=55555):
    sock = socket.socket()
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, port))
    sock.listen()
    while True:
        client_sock, addr = await loop.sock_accept(sock)
        print('Connection from', addr)
        loop.create_task(handle_client(client_sock))


async def handle_client(sock):
    while True:
        received_data = await loop.sock_recv(sock, 4096)
        if not received_data:
            break
        await loop.sock_sendall(sock, received_data)

    print('Client disconnected:', sock.getpeername())
    sock.close()


if __name__ == '__main__':
    loop.create_task(run_server())
    loop.run()

</pre></div><p></p><p>Then we modify the event loop. We decorate generator functions with <code>@types.coroutine</code> so that they can be used with <code>await</code> and run the tasks by calling <code>send(None)</code> instead of <code>next()</code>:</p><p></p><div><pre># event_loop_04_async_await.py

from collections import deque
import selectors
import types


class EventLoopAsyncAwait:
    def __init__(self):
        self.tasks_to_run = deque([])
        self.sel = selectors.DefaultSelector()

    def create_task(self, coro):
        self.tasks_to_run.append(coro)

    @types.coroutine
    def sock_recv(self, sock, n):
        yield 'wait_read', sock
        return sock.recv(n)

    @types.coroutine
    def sock_sendall(self, sock, data):
        yield 'wait_write', sock
        sock.sendall(data)

    @types.coroutine
    def sock_accept(self, sock):
        yield 'wait_read', sock
        return sock.accept()

    def run(self):
        while True:
            if self.tasks_to_run:
                task = self.tasks_to_run.popleft()
                try:
                    op, arg = task.send(None)
                except StopIteration:
                    continue

                if op == 'wait_read':
                    self.sel.register(arg, selectors.EVENT_READ, task)
                elif op == 'wait_write':
                    self.sel.register(arg, selectors.EVENT_WRITE, task)
                else:
                    raise ValueError('Unknown event loop operation:', op)
            else:
                for key, _ in self.sel.select():
                    task = key.data
                    sock = key.fileobj
                    self.sel.unregister(sock)
                    self.create_task(task)

</pre></div><p></p><p>And we're done! We've implemented an <code>async</code>/<code>await</code>-based concurrent server from scratch. It works exactly like the previous version of the server based on <code>yield from</code> and only has a slightly different syntax. </p><p></p><p>By now, you should understand what <code>async</code>/<code>await</code> is about. But you also should have questions about implementation details of generators, coroutines, <code>yield</code>, <code>yield from</code> and <code>await</code>. We're going to cover all of that in the next section.</p><p></p><h2 id="sr-toc-8">How generators and coroutines are implemented *</h2><p></p><p>If you've been following this series, you effectively know how Python implements generators. First recall that <a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-2-how-the-cpython-compiler-works/">the compiler</a> creates a code object for every code block that it encounters, where a code block can be a module, a function or a class body. A code object describes what the code block does. It contains the block's bytecode, constants, variable names and other relevant information. A function is an object that stores the function's code object and such things as the function's name, default arguments and <code>__doc__</code> attribute.</p><p></p><p>A generator function is an ordinary function whose code object has a <code>CO_GENERATOR</code> flag set. When you call a generator function, Python checks for this flag, and if it sees the flag, it returns a generator object instead of executing the function. Similarly, a native coroutine function is an ordinary function whose code object has a <code>CO_COROUTINE</code> flag set. Python check for this flag too and returns a native coroutine object if it sees the flag.</p><p></p><p>To execute a function, Python first creates a frame for it and then executes the frame. A frame is an object that captures the state of the code object execution. It stores the code object itself as well as the values of local variables, the references to the dictionaries of global and built-in variables, the value stack, the instruction pointer and so on.</p><p></p><p>A generator object stores the frame created for the generator function and some utility data like the generator's name and a flag telling whether the generator is currently running or not. The generator's <code>send()</code> method executes the generator's frame just like Python executes frames of ordinary functions – it calls <code>_PyEval_EvalFrameDefault()</code> to enter the <a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-4-how-python-bytecode-is-executed/">evaluation loop</a>. The evaluation loop iterates over the bytecode instructions one by one and does whatever the instructions tell it to do. The only but crucial difference between calling a function and running a generator is that every time you call the function, Python creates a new frame for it, while the generator keeps the same frame between the runs, thus preserving the state.</p><p></p><p>How does Python execute <code>yield</code> expressions? Let's see. Every time the compiler encounters <code>yield</code>, it emits a <code>YIELD_VALUE</code> bytecode instruction. We can use the <a href="https://docs.python.org/3/library/dis.html#opcode-RETURN_VALUE"><code>dis</code></a> standard module to check this:</p><p></p><div><pre># yield.py

def g():
    yield 1
    val = yield 2
    return 3

</pre></div><p></p><div><pre>$ python -m dis yield.py
...
Disassembly of &lt;code object g at 0x105b1c710, file "yield.py", line 3&gt;:
  4           0 LOAD_CONST               1 (1)
              2 YIELD_VALUE
              4 POP_TOP

  5           6 LOAD_CONST               2 (2)
              8 YIELD_VALUE
             10 STORE_FAST               0 (val)

  6          12 LOAD_CONST               3 (3)
             14 RETURN_VALUE

</pre></div><p></p><p><code>YIELD_VALUE</code> tells the evaluation loop to stop executing the frame and return the value on top of the stack (to <code>send()</code> in our case). It works like a <code>RETURN_VALUE</code> instruction produced for a <code>return</code> statement with one exception. It sets the <code>f_stacktop</code> field of the frame to the top of the stack, whereas <code>RETURN_VALUE</code> leaves <code>f_stacktop</code> set to <code>NULL</code>. By this mechanism, <code>send()</code> understands whether the generator yielded or returned the value. In the first case, <code>send()</code> simply returns the value. In the second case, it raises a <code>StopIteration</code> exception that contains the value.</p><p></p><p>When <code>send()</code> executes a frame for the first time, it doesn't actually sends the provided argument to the generator. But it ensures that the argument is <code>None</code> so that a meaningful value is never ignored:</p><p></p><div><pre>&gt;&gt;&gt; def g():
...     val = yield
... 
&gt;&gt;&gt; g().send(42)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't send non-None value to a just-started generator

</pre></div><p></p><p>On subsequent runs, <code>send()</code> pushes the argument onto the stack. The argument is then assigned to a variable by <code>STORE_FAST</code> (or similar instruction) or just popped by <code>POP_TOP</code> if <code>yield</code> does not receive a value. If you couldn't remember before whether generators first yield or receive, you should remember now: first <code>YIELD_VALUE</code>, then <code>STORE_FAST</code>.</p><p></p><p>The compiler emits <code>GET_YIELD_FROM_ITER</code>, <code>LOAD_CONST</code> and <code>YIELD_FROM</code> instructions when it encounters <code>yield from</code>:</p><p></p><div><pre># yield_from.py

def g():
    res = yield from another_gen

</pre></div><p></p><div><pre>$ python -m dis yield_from.py
...
Disassembly of &lt;code object g at 0x1051117c0, file "yield_from.py", line 3&gt;:
  4           0 LOAD_GLOBAL              0 (another_gen)
              2 GET_YIELD_FROM_ITER
              4 LOAD_CONST               0 (None)
              6 YIELD_FROM
              8 STORE_FAST               0 (res)
...

</pre></div><p></p><p>The job of <code>GET_YIELD_FROM_ITER</code> is to ensure that the object to yield from, which is the value on top of the stack, is an iterator. If the object is a generator, <code>GET_YIELD_FROM_ITER</code> leaves it as is. Otherwise, <code>GET_YIELD_FROM_ITER</code> replaces the object with <code>iter(obj)</code>.</p><p></p><p>The first thing <code>YIELD_FROM</code> does is pop a value from the stack. Usually, this value is a value pushed by <code>send()</code>. But <code>send()</code> pushes nothing on the first run, so the compiler emits a <code>LOAD_CONST</code> instruction that pushes <code>None</code> before <code>YIELD_FROM</code>.</p><p></p><p>The second thing <code>YIELD_FROM</code> does is peek the object to yield from. If the value to send is <code>None</code>, <code>YIELD_FROM</code> calls <code>obj.__next__()</code>. Otherwise, it calls <code>obj.send(value)</code>. If the call raises a <code>StopIteration</code> exception, <code>YIELD_FROM</code> handles the exception: it replaces the object on top of the stack (i.e. the object to yield from) with the result, and the frame execution continues. If the call returns a value without exceptions, <code>YIELD_FROM</code> stops the frame execution and returns the value to <code>send()</code>. In the latter case, it also sets the instruction pointer in such a way so that the next execution of the frame starts with <code>YIELD_FROM</code> again. What will be different on the subsequent runs is the state of the object to yield from and the value to send.</p><p></p><p>A native coroutine is basically a generator object that has a different type. The difference between the types is that the <code>generator</code> type implements <code>__iter__()</code> and <code>__next__()</code>, while the <code>coroutine</code> type implements <code>__await__()</code>. The implementation of <code>send()</code> is the same.</p><p></p><p>The compiler emits the same bytecode instructions for an <code>await</code> expression as for <code>yield from</code> except that instead of a <code>GET_YIELD_FROM_ITER</code> instruction it emits <code>GET_AWAITABLE</code>:</p><p></p><div><pre># await.py

async def coro():
    res = await another_coro

</pre></div><p></p><div><pre>$ python -m dis await.py 
...
Disassembly of &lt;code object coro at 0x10d96e7c0, file "await.py", line 3&gt;:
  4           0 LOAD_GLOBAL              0 (another_coro)
              2 GET_AWAITABLE
              4 LOAD_CONST               0 (None)
              6 YIELD_FROM
              8 STORE_FAST               0 (res)
...

</pre></div><p></p><p><code>GET_AWAITABLE</code> checks whether the object to yield from is a native coroutine or a generator-based coroutine, in which case it leaves the object as is. Otherwise, it replaces the object with <code>obj.__await__()</code>.</p><p></p><p>That's basically how generators and coroutines work. If you still have questions left, I recommend you study the CPython source code. See <a href="https://github.com/python/cpython/blob/3.9/Include/cpython/code.h"><code>Include/cpython/code.h</code></a> for the code object definition, <a href="https://github.com/python/cpython/blob/3.9/Include/funcobject.h"><code>Include/funcobject.h</code></a> for the function object definition and <a href="https://github.com/python/cpython/blob/3.9/Include/cpython/frameobject.h"><code>Include/cpython/frameobject.h</code></a> for the frame definition. Look at <a href="https://github.com/python/cpython/blob/3.9/Objects/genobject.c"><code>Objects/genobject.c</code></a> to learn more about generators and coroutines, and look at <a href="https://github.com/python/cpython/blob/3.9/Python/ceval.c"><code>Python/ceval.c</code></a> to learn what different bytecode instructions do.</p><p></p><p>We've figured out how <code>async</code>/<code>await</code> works, but we also need an event loop to run <code>async</code>/<code>await</code> programs. You're unlikely to write your own event loops as we did in this post because that's a lot work. What you usually do instead is use some event loop library. So before we conclude this post, let me say a few words about the library you're most likely to use.</p><p></p><h2 id="sr-toc-9">asyncio</h2><p></p><p><a href="https://docs.python.org/3/library/asyncio.html"><code>asyncio</code></a> came to the Python standard library around the same time <code>async</code>/<code>await</code> was introduced (see <a href="https://www.python.org/dev/peps/pep-3156/">PEP 3156</a>). It does a lot of things, but essentially it provides an event loop and a bunch of classes, functions and coroutines for asynchronous programming. </p><p></p><p>The <code>asyncio</code> event loop provides an interface similar to that of our final <code>EventLoopAsyncAwait</code> but works a bit differently. Recall that our event loop maintained a queue of scheduled coroutines and ran them by calling <code>send(None)</code>. When a coroutine yielded a value, the event loop interpreted the value as an <code>(event, socket)</code> message telling that the coroutine waits for <code>event</code> on <code>socket</code>. The event loop then started monitoring the socket with a selector and rescheduled the coroutine when the event happened.</p><p></p><p>The <code>asyncio</code> event loop is different in that it does not maintain a queue of scheduled coroutines but only schedules and invokes callbacks. Nevertheless, it provides <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.create_task"><code>loop.create_task()</code></a> and other methods to schedule and run coroutines. How does it do that? Let's see.</p><p></p><p>The event loop maintains three types of registered callbacks:</p><p></p><ul>
<li>
<p>The ready callbacks. These are stored in the <code>loop._ready</code> queue and can be scheduled by calling the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon"><code>loop.call_soon()</code></a> and <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon_threadsafe"><code>loop.call_soon_threadsafe()</code></a> methods.</p>
</li>
<li>
<p>The callbacks that become ready at some future time. These are stored in the <code>loop._scheduled</code> priority queue and can be scheduled by calling the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_later"><code>loop.call_later()</code></a> and <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_at"><code>loop.call_at()</code></a> methods.</p>
</li>
<li>The callbacks that become ready when a file descriptor becomes ready for reading or writing. These are monitored using a selector and can be registered by calling the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.add_reader"><code>loop.add_reader()</code></a> and <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.add_writer"><code>loop.add_writer()</code></a> methods.</li>
</ul><p></p><p>The methods listed above wrap the callback to be scheduled in a <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Handle"><code>Handle</code></a> or a <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.TimerHandle"><code>TimerHandle</code></a> instance and then schedule and return the handle. <code>Handle</code> instances provide the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Handle.cancel"><code>handle.cancel()</code></a> method that allows the caller to cancel the callback. <code>TimerHandle</code> is a subclass of <code>Handle</code> for wrapping callbacks scheduled at some future time. It implements the comparison special methods like <a href="https://docs.python.org/3/reference/datamodel.html#object.__le__"><code>__le__()</code></a> so that the sooner a callback is scheduled the less it is. Due to <code>TimerHandle</code>, the <code>loop._scheduled</code> priority queue keeps callbacks sorted by time.</p><p></p><p>The <a href="https://github.com/python/cpython/blob/b2f68b190035540872072ac1d2349e7745e85596/Lib/asyncio/base_events.py#L1802"><code>loop._run_once()</code></a> method runs one iteration of the event loop. The iteration consists of the following steps:</p><p></p><ol>
<li>Remove cancelled callbacks from <code>loop._scheduled</code>.</li>
<li>Call <code>loop._selector.select()</code> and then process the events by adding the callbacks to <code>loop._ready</code>.</li>
<li>Move callbacks whose time has come from <code>loop._scheduled</code> to <code>loop._ready</code>.</li>
<li>Pop callbacks from <code>loop._ready</code> and invoke those that are not cancelled.</li>
</ol><p></p><p>So, how does this callback-based event loop run coroutines? Let's take a look at the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.create_task"><code>loop.create_task()</code></a> method. To schedule a coroutine, it wraps the coroutine in a <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task"><code>Task</code></a> instance. The <code>Task.__init__()</code> method schedules <code>task.__step()</code> as a callback by calling <code>loop.call_soon()</code>. And this is the trick: <code>task.__step()</code> runs the coroutine.</p><p></p><p>The <a href="https://github.com/python/cpython/blob/b2f68b190035540872072ac1d2349e7745e85596/Lib/asyncio/tasks.py#L215"><code>task.__step()</code></a> method runs the coroutine once by calling <code>coro.send(None)</code>. The coroutine doesn't yield messages. It can yield either <code>None</code> or a <code>Future</code> instance. <code>None</code> means that the coroutine simply wants to yield the control. This is what <code>asyncio.sleep(0)</code> does, for example. If a coroutine yields <code>None</code>, <code>task.__step()</code> simply reschedules itself.</p><p></p><p>A <a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future"><code>Future</code></a> instance represents the result of some operation that may not be available yet. When a coroutine yields a future, it basically tells the event loop: "I'm waiting for this result. It may not be available yet, so I'm yielding the control. Wake me up when the result becomes available".</p><p></p><p>What does <code>task.__step()</code> do with a future? It calls <code>future.add_done_callback()</code> to add to the future a callback that reschedules <code>task.__step()</code>. If the result is already available, the callback is invoked immediately. Otherwise, it's invoked when someone/something sets the result by calling <code>future.set_result()</code>.</p><p></p><p>Native coroutines cannot <code>yield</code>. Does it mean that we have to write a generator-based coroutine any time we need to <code>yield</code> a future? No. Native coroutines can simply <code>await</code> on futures, like so:</p><p></p><div><pre>async def future_waiter():
    res = await some_future

</pre></div><p></p><p>To support this, futures implement <code>__await__()</code> that yields the future itself and then returns the result:</p><p></p><div><pre>class Future:
    # ...

    def __await__(self):
        if not self.done():
            self._asyncio_future_blocking = True
            yield self  # This tells Task to wait for completion.
        if not self.done():
            raise RuntimeError("await wasn't used with future")
        return self.result()  # May raise too.

</pre></div><p></p><p>What sets the result on a future? Let's take a function that creates a future for the socket incoming data as an example. Such a function can be implemented as follows:</p><p></p><ol>
<li>Create a new <code>Future</code> instance.</li>
<li>Call <code>loop.add_reader()</code> to register a callback for the socket. The callback should read data from the socket and set the data as the future's result.</li>
<li>Return the future to the caller.</li>
</ol><p></p><p>When a task awaits on this future, it will yield the future to <code>task.__step()</code>. The <code>task.__step()</code> method will add a callback to the future, and this callback will reschedule the task when the callback from step 2 sets the result.</p><p></p><p>We know that a coroutine can wait for the result of another coroutine by awaiting on that coroutine:</p><p></p><div><pre>async def coro():
    res = await another_coro()

</pre></div><p></p><p>But it can also schedule the coroutine, get a <code>Task</code> instance and then <code>await</code> on the task:</p><p></p><div><pre>async def coro():
    task = asyncio.create_task(another_coro())
    res = await task

</pre></div><p></p><p><code>Task</code> subclasses <code>Future</code> so that tasks can be awaited on. What sets the result on a task? It's <code>task.__step()</code>. If <code>coro.send(None)</code> raises a <code>StopIteration</code> exception, <code>task.__step()</code> handles the exception and sets the task's result.</p><p></p><p>And that's basically how the core of <code>asyncio</code> works. There two facts about it that we should remember. First, the event loop is based on callbacks, and the coroutine support is implemented on top of that. Second, coroutines do not yield messages to the event loop but yield futures. Futures allow coroutines to wait for different things, not only for I/O events. For example, a coroutine may submit a long-running computation to a separate thread and <code>await</code> on a future that represents the result of the computation. We <a href="https://github.com/r4victor/pbts12_async_await/blob/master/event_loop_05_thread.py">could</a> implement such a coroutine on top of sockets, but it would be less elegant and general than the solution with a future.</p><p></p><h2 id="sr-toc-10">Conclusion</h2><p></p><p>The <code>async</code>/<code>await</code> pattern has gained popularity in recent years. Concurrency is as relevant today as ever, and traditional approaches for achieving it, such as OS threads and callbacks, cannot always provide an adequate solution. OS threads work fine in some cases, but in many other cases the concurrency can be implemented much better at the language/application level. A callback-based event loop is technically as good as any <code>async</code>/<code>await</code> solution, but who likes writing callbacks?</p><p></p><p>It's not to say that <code>async</code>/<code>await</code> is the only right approach to concurrency. Many find other approaches to be better. Take the <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">communicating sequential processes model</a> implemented in <a href="https://golang.org/doc/effective_go#concurrency">Go</a> and <a href="https://clojuredocs.org/clojure.core.async">Clojure</a> or the <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a> implemented in <a href="https://erlang.org/doc/getting_started/conc_prog.html">Erlang</a> and <a href="https://doc.akka.io/docs/akka/current/typed/guide/introduction.html">Akka</a> as examples. Still, <code>async</code>/<code>await</code> seems to be the best model we have in Python today.</p><p></p><p>Python didn't invent <code>async</code>/<code>await</code>. You can also find it in <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/">C#</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">JavaScript</a>, <a href="https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html">Rust</a>, and <a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html">Swift</a>, to name a few. I'm biased towards Python's implementation because I understand it best, but objectively, it's not the most refined. It mixes generators, generator-based coroutines, native coroutines, <code>yield from</code> and <code>await</code>, which makes it harder to understand. Nevertheless, once you understand these concepts, Python's <code>async</code>/<code>await</code> seems pretty straightforward.</p><p></p><p><code>asyncio</code> is a solid library, but it has its issues. The callback-based event loop allows <code>asyncio</code> to provide an API for both callback-style and <code>async</code>/<code>await</code>-style programming. But an event-loop that runs coroutines directly, like those that we wrote in this post, <a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/#other-challenges-for-hybrid-apis">can be much simpler</a> in both implementation and usage. The <a href="https://github.com/dabeaz/curio"><code>curio</code></a> and <a href="https://github.com/python-trio/trio"><code>trio</code></a> modules are notable alternatives to <code>asyncio</code> that take this approach.</p><p></p><p>To sum up, concurrency is inherently hard, and no programming model can make it easy. Some models make it manageable, though, and this post should help you master one such model – Python's <code>async</code>/<code>await</code>.</p><p></p><h2 id="sr-toc-11">P.S.</h2><p></p><p>The code for this post is available on <a href="https://github.com/r4victor/pbts12_async_await">github</a>. The post is inspired by David Beazley's <a href="https://www.youtube.com/watch?v=Z_OAlIhXziw">Curious Course on Coroutines and Concurrency</a> talk and by Eli Bendersky's <a href="https://eli.thegreenplace.net/2017/concurrent-servers-part-1-introduction/">Concurrent Servers</a> series.</p><p></p><p><code>async</code>/<code>await</code> completes the list of topics I wanted to cover in the Python behind the scenes series. I'm now planning to write about other interesting things, but the series is likely to get a sequel in the future. If you want to suggest a topic for the <a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-13-the-gil-and-its-effects-on-python-multithreading/">next post</a>, you can write me an email to victor@tenthousandmeters.com.</p><p></p><p><em>If you have any questions, comments or suggestions, feel free to contact me at victor@tenthousandmeters.com</em></p><p></p><p><strong>Update from August 27, 2021</strong>:  The relationship between concurrency and parallelism is more subtle. Usually, concurrency is viewed as a property of a program and parallelism as a property of a program execution. Thus, you can have "parallelism without concurrency" – even the execution of a sequentially-looking program involves <a href="https://en.wikipedia.org/wiki/Instruction-level_parallelism">instruction-level</a> or <a href="https://en.wikipedia.org/wiki/Bit-level_parallelism">bit-level parallelism</a>. Task-level parallelism is indeed a special case of concurrency.</p><p></p></sr-rd-content>
                            
                            <sr-rd-footer>
                                <sr-rd-footer-group>
                                    <sr-rd-footer-line></sr-rd-footer-line>
                                    <sr-rd-footer-text>全文完</sr-rd-footer-text>
                                    <sr-rd-footer-line></sr-rd-footer-line>
                                </sr-rd-footer-group>
                                <sr-rd-footer-copywrite>
                                    <div>本文由 <a href="http://ksria.com/simpread" target="_blank">简悦 SimpRead</a> 转码，用以提升阅读体验，<a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-12-how-asyncawait-works-in-python/" target="_blank">原文地址 </a></div>
                                </sr-rd-footer-copywrite>
                            </sr-rd-footer>
                        </sr-read>
                    </body>
                </html>